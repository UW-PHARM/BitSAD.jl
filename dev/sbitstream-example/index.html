<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Stochastic Bitstream Walkthrough · BitSAD.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">BitSAD.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Introduction</span><ul><li><a class="tocitem" href="../getting-started/">Getting started</a></li><li class="is-active"><a class="tocitem" href>Stochastic Bitstream Walkthrough</a><ul class="internal"><li><a class="tocitem" href="#Notes-and-Considerations-1"><span>Notes and Considerations</span></a></li></ul></li><li><a class="tocitem" href="../dbitstream-example/">Deterministic Bitstream Walkthrough</a></li></ul></li><li><span class="tocitem">Types</span><ul><li><a class="tocitem" href="../bitstream/">Abstract Bitstreams</a></li><li><a class="tocitem" href="../sbitstream/">Stochastic Bitstreams</a></li><li><a class="tocitem" href="../dbitstream/">Deterministic Bitstreams</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Introduction</a></li><li class="is-active"><a href>Stochastic Bitstream Walkthrough</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Stochastic Bitstream Walkthrough</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/UW-PHARM/BitSAD.jl/blob/master/docs/src/sbitstream-example.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Walking-through-an-SBitstream-Example-1"><a class="docs-heading-anchor" href="#Walking-through-an-SBitstream-Example-1">Walking through an <code>SBitstream</code> Example</a><a class="docs-heading-anchor-permalink" href="#Walking-through-an-SBitstream-Example-1" title="Permalink"></a></h1><p>Now let&#39;s walk through an <code>SBitstream</code> example program to compute the iterative SVD of a matrix. Here&#39;s an overview of the mathematical algorithm:</p><hr/><p><strong>Input:</strong> Matrix <span>$A$</span> and inital guess <span>$v_0$</span> <br/> <strong>Steps: (for <span>$T$</span> iterations)</strong></p><ol><li><span>$w_k \gets Av_{k - 1}$</span></li><li><span>$u_k \gets w_k / \|w_k\|_2$</span></li><li><span>$z_k \gets A^\top v_{k - 1}$</span></li><li><span>$\sigma_k \gets \|z_k\|_2$</span></li><li><span>$v_k \gets z_k / \sigma_k$</span></li></ol><p><strong>Return:</strong> First singular value and vectors, <span>$\sigma_T, u_T, v_T$</span></p><hr/><p>First we import BitSAD and create a module for our algorithm. There is no fixed way for defining an algorithm, but we recommend defining a struct. This way, the fields of the struct represent the submodules and internal parameters of the algorithm.</p><pre><code class="language-julia">using BitSAD

struct IterativeSVD
    rows::Int
    cols::Int
end</code></pre><p>Above, we created the <code>IterativeSVD</code> module that is parameterized by the number of rows and columns in the matrix. Structs in Julia are callable, which means we can call the module like a function.</p><pre><code class="language-julia">function (dut::IterativeSVD)(A::Matrix{SBit}, v₀::Vector{SBit})
    # Update right singular vector
    w = A * v₀
    wscaled = w .÷ sqrt(dut.rows)
    u = wscaled ./ norm(wscaled)

    # Update left singular vector
    z = permutedims(A) * u
    zscaled = z .÷ sqrt(dut.cols)
    σ = norm(zscaled)
    v = zscaled ./ σ

    return u, v, σ
end</code></pre><p>Here we defined the algorithm as accepting a matrix of <code>SBit</code>s and a vector of <code>SBit</code>s. Though directly operating on <code>SBitstream</code>s is supported, this is mostly intended for REPL-style work. If you are writing a program that you intend to map to hardware, it should operate directly on <code>SBit</code>s. This should be intuitive — a stochastic bitstream circuit operates on a single bit at a time. In this way, you should aim for your modules to describe what happens in a single iteration. Lastly, it is also worth noting here how closely the function body matches the algorithm above.</p><p>That&#39;s all it takes to define a bitstream computing algorithm in BitSAD. Of course, we don&#39;t just want to define the algorithm, we want to test and use it! To do that, we&#39;ll need to create some test matrices.</p><pre><code class="language-julia">using Makie, DataStructures
using Statistics: mean
using LinearAlgebra

N = 10     # number of trials
T = 20000  # length of each trial
m = 2      # number of rows in matrix
n = 2      # number of columns in matrix

# generate inputs
A = [2 .* rand(m, n) .- 1 for i in 1:N]
v₀ = [rand(n) for i in 1:N]
v₀ .= v₀ ./ norm.(v₀)
dut = [IterativeSVD(m, n) for i in 1:N]

# calculate scaling
α = 2 .* max.(norm.(A, Inf), norm.(A, 1))
A = A ./ α

# convert to bitstream
A = SBitstream.(A)
v₀ = SBitstream.(v₀)</code></pre><p>The code above generates an array of matrices to decompose and initial guesses. It also calculates a scaling factor to prevent the stochastic bitstreams from saturating when we run multiple iterations of the algorithm. This is an important consideration for stochastic computing, and BitSAD can allow users to empirical determine the correct scaling level. In this case, we determined theoretical scaling factors beforehand. If a bitstream variable was to saturate during computation, then BitSAD will print a warning out. In the last few lines, we take the floating-point matrices and vectors that we generated, and we create <code>SBitstream</code> objects out of them.</p><pre><code class="language-julia"># eval loop
BitSAD.clearops()
ϵ = zeros(T, N)
ubuffer = [CircularBuffer{Vector{Int}}(5000) for i in 1:N]
vbuffer = [CircularBuffer{Vector{Int}}(5000) for i in 1:N]
σbuffer = [CircularBuffer{Int}(5000) for i in 1:N]
Threads.@threads for trial in 1:N
    generate!.(A[trial], T)
    generate!.(v₀[trial], 1000)

    for t in 1:T
        # evaluate module
        output = dut[trial](pop!.(A[trial]), pop!.(v₀[trial]))
        (t &gt;= 1000) &amp;&amp; push!.(v₀[trial], decorrelate.(output[2]))

        # accumulate results in buffer
        u = estimate!(ubuffer[trial], output[1])
        v = estimate!(vbuffer[trial], output[2])
        σ = estimate!(σbuffer[trial], output[3])

        # record loss
        ϵ[t, trial] = norm(α[trial] * (float.(A[trial]) * v - u * σ * sqrt(n)))
    end

    println(&quot;Completed trial $trial&quot;)
end</code></pre><p>The loop above is the actual test loop. The line <code>BitSAD.clearops()</code> resets the internal data structures utilized by BitSAD. It is not required in this case, but it can be good practice to make sure no previous operations conflict with what is about to be run. For more information on this see <a href="@ref">Internals</a>.</p><p>We also instantiated some <code>CircularBuffer</code>s to keep track of the last 5000 bit samples of each output bitstream. This is not required, but we often want to keep a running windowed average of a bitstream to see if the empirical average matches the true real number the bitstream should encode.</p><p>Next, we called <code>generate!</code> on the matrix and vector that is the input for this trial. This will sample from the Bernoulli distribution that models each bitstream and push the samples onto their queues. Recall from <a href="../getting-started/#Operating-on-Bitstreams-1">Operating on Bitstreams</a> that this is not required, but pre-generating the samples can improve performance for lengthy trials.</p><p>Finally, we enter the main loop that runs over <code>T</code> iterations and exercises an <code>IterativeSVD</code> for each step. The line <code>dut[trial](pop.!(A[trial]), pop!.(v₀[trial]))</code> is how we call our struct. If we weren&#39;t running for many trials, we wouldn&#39;t have multiple objects, and the call might look more like <code>dut(pop!.(A), pop!.(v₀))</code>. This call produces <code>output</code> which is the tuple returned by our algorithm. One element of this tuple, <span>$v_k$</span>, is passed back into our algorithm as an input. We can pass each returned vector or scalar <code>SBit</code> to the <code>estimate!</code> function from BitSAD. This function is a handy utility function that updates the circular buffers and returns the current empirical average. The last step of the loop body is to compute and store the current algorithm error.</p><pre><code class="language-julia">u = @. estimate!(ubuffer)
v = @. estimate!(vbuffer)
σ = @. estimate!(σbuffer) * sqrt(n)
A = map(λ -&gt; float.(λ), A)
f = svd(A[1])
println(&quot;u error: $(u[1] - f.U[1, :])&quot;)
println(&quot;v error: $(v[1] - f.V[1, :])&quot;)
println(&quot;σ error: $(σ[1] - f.S[1])&quot;)
println(&quot;  error: $(mean(norm.(α .* (A .* v .- u .* σ))))&quot;)
scene = lines(dropdims(mean(ϵ; dims = 2); dims = 2), color = :blue)
axis = scene[Axis]
axis[:names][:axisnames] = (&quot;Iteration #&quot;, &quot;Loss&quot;)
scene = title(scene, &quot;Iterative SVD Loss Over $T Iterations&quot;, textsize = 15)

scene</code></pre><p>Once the simulation is run, we can use the code above to examine the results. <code>u = @. estimate!(ubuffer)</code> returns the current average in the circular buffer. The rest of the code is not specific to BitSAD, instead it is just some plotting code to visualize the error over the <code>T</code> iterations.</p><h2 id="Notes-and-Considerations-1"><a class="docs-heading-anchor" href="#Notes-and-Considerations-1">Notes and Considerations</a><a class="docs-heading-anchor-permalink" href="#Notes-and-Considerations-1" title="Permalink"></a></h2><p>The purpose of this example is not to teach you about bitstream computing or explain every function call. Rather it is walk through the high level process of designing a BitSAD program. See <a href="../bitstream/#Bitstreams-1">Bitstreams</a> for more information on the <code>SBitstream</code> type and operators on them.</p><p>You may have notice we glossed over the <code>(t &gt;= 1000) &amp;&amp; push!.(v₀[trial], decorrelate.(output[2]))</code> line. Normally, we cannot directly feedback an output of a bitstream computing algorithm into its inputs. This would violate a critical assumption of stochastic computing. Instead, we pass the output through a decorrelator which is a hardware unit that creates a new i.i.d. bitstream from its input. In BitSAD, this is done by calling the <code>decorrelate</code> function. We then push the decorrelated bit sample onto <code>v₀[trial]</code>&#39;s queue. Notice that we only do this for <code>t &gt;= 1000</code>. This is for stability reasons. It allows the algorithm to receive a stable input for a 1000 iterations before we allow continuous feedback.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting-started/">« Getting started</a><a class="docs-footer-nextpage" href="../dbitstream-example/">Deterministic Bitstream Walkthrough »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 20 March 2020 03:25">Friday 20 March 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
