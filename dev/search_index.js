var documenterSearchIndex = {"docs":
[{"location":"getting-started/#Getting-Started-1","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"BitSAD allows you to perform linear algebra arithmetic with bitstreams. A bitstream is a sequence of single bit values that represents some data. There are two types of bitstreams in BitSAD — stochastic bitstream (SBitstream) and deterministic bitstreams (DBitstream).","category":"page"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"Stochastic bitstreams refer to bit sequences found in stochastic computing. Such bitstreams are modeled as a Bernoulli sequence whose mean is the real number being encoded. Deterministic bitstreams refer to pulse density modulated audio data. In this case, the density of high bits is proportional to the amplitude of the audio signal.","category":"page"},{"location":"getting-started/#Creating-Bitstreams-1","page":"Getting Started","title":"Creating Bitstreams","text":"","category":"section"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"Creating a bitstream variable is straightforward:","category":"page"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"x = SBitstream(0.1)\ny = DBitstream()","category":"page"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"Here x is a stochastic bitstream representing the real number 0.1. y is a deterministic bitstream. Deterministic bitstreams don't represent a single underlying value, so the constructor receives no arguments. Any bitstream object contains a queue of bits that holds the internal sequence of bits. Upon creation, neither x nor y have any bits in their queue. Below, in Operating on Bitstreams, you will see how to add bits to their queues.","category":"page"},{"location":"getting-started/#Operating-on-Bitstreams-1","page":"Getting Started","title":"Operating on Bitstreams","text":"","category":"section"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"Both types of bitstreams inherit from a shared abstract type — AbstractBitstream. If you were to create your own bitstream type, you would need to inherit from this abstract type. This allows us to define some shared operations that apply to all bitstreams. For example, we can push and pop bits from bitstreams:","category":"page"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"x = SBitstream(0.1)\ny = DBitstream()\n\npush!(y, DBit(false)) # add a low bit to y's queue\npop!(y) == DBit(false) # true\nprint(pop!(x)) # prints a randomly generated bit according to Bernoulli(0.1)\npop!(y) # ERROR!","category":"page"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"In the example above, we pushed and popped a bit from y, a deterministic bitstream. You cannot pop! from an empty DBitstream. This is allowed for SBitstreams though. Since a stochastic bitstream is modeled as a Bernoulli sequence, we sample from that distribution to generate a new bit whenever the queue is empty. If you do push bits onto an SBitstream's queue, then those bits will be popped first before any new bits are generated.","category":"page"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"Once there are bits in the queue (or not for SBitstreams), you can perform arithmetic:","category":"page"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"x = SBitstream(0.1)\ny = SBitstream(0.3)\n\n# this expression will pop randomly generated bits\n# from x and y, then add those bits and return\n# a new SBitstream object with the result bit\n# in its queue\nx + y","category":"page"},{"location":"getting-started/#Under-the-Hood-1","page":"Getting Started","title":"Under the Hood","text":"","category":"section"},{"location":"getting-started/#","page":"Getting Started","title":"Getting Started","text":"What does the comment in the above example mean? In hardware, a bitstream computing program is represented by a circuit. A stream of bits enters the circuit inputs, and each bit is processed one-by-one to produce an output bitstream. So, x + y is an operator that works on single bits. We mentioned that all bitstreams have a queue containing the underlying sequence of bits. For SBitstreams, this is a sequence of SBits. The + operator is defined for SBits to add two inputs bit samples according to the hardware specification. In other words, when you run x + y, the result is computed exactly as it would be in hardware. In this way, BitSAD allows users to write programs at a high algorithmic level, simulate the hardware results, verify the results, then map the program to Verilog.","category":"page"},{"location":"#BitSAD.jl-1","page":"Home","title":"BitSAD.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"BitSAD is a domain-specific language for bitstream computing. It aims to provide a general purpose linear algebra interface for writing algorithms that can be mapped to bitstream computing hardware. Programs written in BitSAD can be turned into synthesizable, verified Verilog code.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"See CITATION.bib for how to cite BitSAD if you use it in your research.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"You can install BitSAD by opening a Julia REPL and entering:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"> ] add https://github.com/UW-PHARM/BitSAD.jl","category":"page"}]
}
