[{"body":"private   SSignedSubtractor   —   struct A signed stochastic bitstream subtract operator .","id":"docstrings/BitSAD.SSignedSubtractor.html"},{"body":"Installation You can install BitSAD by opening a Julia REPL and entering (note that the  ]  indicates  Pkg mode ):","id":"README.html#installation"},{"body":"private   SSignedAdder   —   struct A signed stochastic bitstream add operator .","id":"docstrings/BitSAD.SSignedAdder.html"},{"body":"private   trace   —   function Trace the function call  f(args...)  and return the  Ghost.Tape . Callables in  submodules  are considered primitive operators . This function is not meant to be called by users . Users should use  simulatable  or  generatehw  instead .","id":"docstrings/BitSAD.trace.html"},{"body":"Quick start BitSAD allows you to write programs that operate on bitstreams .  A bitstream is a sequence of single bit values that represents some data .  The following tutorial will help you get started with BitSAD if you already have familiarity with bitstream computing .  For a more detailed tutorial, see  stochastic bitstreams 101 . Currently, BitSAD defines  SBitstream  to refer to bit sequences found in  stochastic computing .  Such bitstreams are modeled as a Bernoulli sequence whose mean is the true number being encoded .","id":"docs/tutorials/getting-started.html#quick-start"},{"body":"Basics of stochastic bitstreams First, let ’ s try creating a stochastic bitstream . Here, we created a  SBitstream  (the type in BitSAD for stochastic bitstreams) encoding the real value 0 . 3 .   SBitstream  will keep track of the mean of the Bernoulli distribution, which we can recover with  float . You ’ ll also notice that there were  “ 0 bits enqueue ”  in  x .  This refers to the fact that the bitstream,  x , is a sequence of samples .  Currently, we have not drawn any samples from  x .  We can try that now: Now, we have a single sample,  xt , which is of type  SBit .  An  SBit  is a  “ stochastic bit ”  which is just a convenient alias for a  NamedTuple  with two parts  —  the positive part ( pos ) and the negative part ( neg ) . Wait, I thought stochastic bitstreams were a single bit sequence?  —  You (probably) Yes, in theory, but this definition means that we can only represent real numbers  .  In practice, we would like to represent signed numbers (though we still normalize them to  ) .  BitSAD uses a two - channel format for encoding signed numbers as two underlying bitstreams .  One channel is the positive part and the other is the negative part, such that Samples from these two separate channels are neatly packaged into a single  SBit  so that we can think of  SBitstream s as a sequence of  SBit s without having to worry too much about the underlying signed encoding scheme . If we want, we can even add  SBit s onto a  SBitstream . We see that  x  now has a single bit in queue .  For convenience, BitSAD provides  generate!  to pre - load a  SBitstream  with samples from the underlying distributions . Finally, we can see that the empirical average over the  SBit s in queue matches to encoded value quite closely .","id":"docs/tutorials/sbitstream.html#basics-of-stochastic-bitstreams"},{"body":"public   simulatable   —   function Return a simulatable variation of  f(args...)  that emulates the bit - level operations for  SBitstream  variables . The returned function, call it  sim , can be called via  sim(f, args...) . This is done by recursively tracing the execution of  f(args...)  then replacing each primitive simulatable operation with a simulatable operator .","id":"docstrings/BitSAD.simulatable.html"},{"body":"private   is_trace_primitive   —   function Return true if calling a callable of type  ftype  on arguments of types  argtypes  is a BitSAD primitive operator . Custom operators should overload this function . Defaults to false .","id":"docstrings/BitSAD.is_trace_primitive.html"},{"body":"private   squashable   —   function Return true if a callable of type  ftype  is a “ squashable ”  2 - arg function . Defaults to false . Functions like  +  are n - arg functions in Julia, but most hardware designers think of them as 2 - arg . When  squashable  returns true, BitSAD ’ s tracing engine will “ squash ”  a single n - arg call into nested 2 - arg calls .","id":"docstrings/BitSAD.squashable.html"},{"body":"Name Module Visibility Category  @nosim   BitSAD   private   macro   CircuitModule   BitSAD   private   parametric type   Net   BitSAD   private   parametric type   SBitstream   BitSAD   public   parametric type   SL2Normer   BitSAD   private   struct   SSignedAdder   BitSAD   private   struct   SSignedDecorrelator   BitSAD   private   struct   SSignedDivider   BitSAD   private   struct   SSignedFixedGainDivider   BitSAD   private   struct   SSignedMatMultiplier   BitSAD   private   struct   SSignedMultiplier   BitSAD   private   struct   SSignedSubtractor   BitSAD   private   struct   SSquareRoot   BitSAD   private   struct   SimulatableContext   BitSAD   private   struct   bitwidth   BitSAD   private   function   estimate!   BitSAD   public   function   estimate   BitSAD   public   function   generate   BitSAD   public   function   generatehw   BitSAD   public   function   gethandler   BitSAD   private   function   getsimulator   BitSAD   private   function   is_simulatable_primitive   BitSAD   private   function   is_trace_primitive   BitSAD   private   function   jltypeof   BitSAD   private   function   name   BitSAD   private   function   netsize   BitSAD   private   function   show_simulatable   BitSAD   private   function   simulatable   BitSAD   public   function   simulator   BitSAD   private   function   squashable   BitSAD   private   function   suffixes   BitSAD   private   function   trace   BitSAD   private   function   transform!   BitSAD   private   function   value   BitSAD   private   function ","id":"docstrings.html#docstring-index"},{"body":"Define the power iteration function We begin by defining the five steps as a plain function in Julia: The function  power_iteration  is almost an exact copy of the mathematical algorithm, except we do some additional scaling to  w  and  z .  We ’ ll see why in a moment .  For now, let ’ s test it on a random matrix to see if it works as expected . Unfortunately, our result is incorrect, but we can see that BitSAD reported saturation occuring several times .  Let ’ s try this again, but now, we ’ ll pre - scale  A  so that none of the operations in the algorithm saturate (more details on the choice of scaling are in  our paper ) .  Note that this is also the reason why we scaled  w  and  z  in the original function (so that  norm(w)  did not saturate) . Without saturation, our results are more accurate .","id":"docs/tutorials/iterative-svd.html#define-the-power-iteration-function"},{"body":"Simulating the power iteration The test above only verified that the basic algorithm worked with the limited numeric range of stochastic bitstreams .  It did not verify that bit - level operations would converge as well .  Let ’ s try that next . Since we are simulating bits, we need to store the bits in order to compute an estimate of the current simulation output .  We use a  CircularBuffer  from DataStructures . jl to do this .  Additionally, in the previous section, we directly fed back the output,  v , as an input in the subsequent iteration .  Now,  v  is unstable during the first few iterations, so we only start the feedback after 1,000 iterations .  Finally, we measure the output error using the formula Any valid SVD will satisfy this property .  Our error is how closely this property holds for our current estimates .  We chose to use this error to illustrate how  estimate!  can be used to mix floating point and bitstream computation .","id":"docs/tutorials/iterative-svd.html#simulating-the-power-iteration"},{"body":"private   SSignedMultiplier   —   struct A signed stochastic bitstream multiply operator .","id":"docstrings/BitSAD.SSignedMultiplier.html"},{"body":"private   @nosim   —   macro Mark a function call of the form  f(x, y::T, ...)  as a simulation primitive . This will prevent BitSAD ’ s simulation engine for recursing this function, and instead use the return value of  f  directly (without simulating it) . Arguments may or may not have a type specified . Set  kwargs=true  if  f  accepts keyword arguments . Note that the type and name of keywords cannot be specified . If  f(x, y, ...)  has a corresponding simulatable operator, then define  BitSAD.getsimulator  for  f .","id":"docstrings/BitSAD.@nosim.html"},{"body":"private   suffixes   —   function Return the suffixes for  x .","id":"docstrings/BitSAD.suffixes.html"},{"body":"Create a simulation nop A  “ nop ”  (or  “ no op ” ) is an operation that passes its inputs through unmodified .  A  simulation nop  is a function that is not traced by the BitSAD simulator .  Instead, that call stack is  “ passed through ”  unmodified .  Let ’ s look at a concrete example . If we look at the transformed simulation code for  h , we see that BitSAD recurses into the call stack of  f . Suppose instead of unwrapping the call to  f , we want the simulator to call  f  itself on the plain arguments .  We can do this with  BitSAD.@nosim . By declaring  f(x)  as a simulation nop, we prevent BitSAD from tracing into  any  call matching  f(::Any) .  Instead, BitSAD will call  f(x) . You can use type signatures to restrict which methods of a function are marked as simulation nops .  For example,  f(x::SBitstream)  will only prevent tracing into  f  when  typeof(x) <: SBitstream .  When no type signature is given, the argument type defaults to  Any . Notice that  f  is called on  x2  directly (i . e .  there is no call to  getbit ) .  Marking a call as a simulation nop bypasses the  getbit / setbit!  calls inserted by the simulator for  all  arguments .","id":"docs/how-tos/nosim.html#create-a-simulation-nop"},{"body":"Arguments name::String : the name of the net (this can be a SystemVerilog constant expression too) suffixes::Vector{String} : set if this net represents multiple wires with suffixes (e . g .  a signed stochastic bitstream has suffixes  _p  and  _m ) value : the underlying Julia value that this net represents type::Symbol : one of  [ :logic ]  (a SystemVerilog type) class::Symbol : one of  [ :input, :output, :internal, :constant, :parameter ] signed::Bool : set true if the net is signed in SystemVerilog bitwidth::Int : the bit width of each element in the net size::Tuple{Int, Int, ...} : the size of the net in terms of number of elements If  x  is specified, then  value = x  and  size = netsize(x) . netsize  is like  Base.size , but it expands scalars and vectors to 2D sizes (e . g .   (1, 1) ) If  x  is a  SBitstream  or  AbstractArray{<:SBitstream} , then  suffixes = [\"_p\", \"_m\"] .","id":"docstrings/BitSAD.Net.html#arguments"},{"body":"private   bitwidth   —   function Return the bitwidth of elements of  x","id":"docstrings/BitSAD.bitwidth.html"},{"body":"private   CircuitModule   —   parametric type A data structure to store information to generate hardware for  fn . Hardware generation traverses  dfg  and uses  handlers  to generate Verilog strings .","id":"docstrings/BitSAD.CircuitModule.html"},{"body":"private   jltypeof   —   function Return the type of the underlying Julia value that  x  represents .","id":"docstrings/BitSAD.jltypeof.html"},{"body":"Simulating functions on  SBitstream s Suppose we have the following function,  f , which multiplies two  SBitstream s . We see that the output,  z , is similar to the  previous tutorial .  Instead of manually simulating the bit - level multiplication in  f , we can use  simulatable . fsim  is a Julia function that can be called similar to  f  (the exception being that  fsim  expects the first argument to be the function to simulate,  f ) . For static functions like  f , it may see redundant to pass  f  in .  But the simulated function can be a  callable struct  as well .  This means that you can modify the struct between invocations of the simulation object if you desire . BitSAD generates  fsim  by executing  f(x, y)  once and storing the program execution on a trace .  This trace gets transformed into a similar program except calls to operations are replaced by calls to simulators .  These simulators emulate the bit - level execution, similar to  multiply_sbit  from the previous tutorial . Let ’ s verify that  fsim  works like our manual simulation from before . What ’ s actually happening inside  fsim ? We can take a peek under the hood with  show_simulatable  which will print out the Julia function being compiled by BitSAD . Here, we see that  fsim  is a function that accepts two  SBitstream{Float64} s as input .  Walking through each step, we see: x3 = getbit(x2)  pops a sample from the first input (similarly,  x5 = getbit(x4) ) . The regular  *(x2, x4)  is called on our input  SBitstream s to produce the output  SBitstream ,  x6 . A simulator,  SSignedMultiplier  is called on the popped bits,  x3  and  x4 . The resulting  SBit ,  x7 , is pushed onto the output bitstream with  setbit!(x6, x7) . These four steps are the basic transformation applied to any simulatable operation on the trace .","id":"docs/tutorials/simulation-and-hardware.html#simulating-functions-on-sbitstreams"},{"body":"Power iteration for SVD The  singular value decomposition  (SVD) is a fundamental decomposition in linear algebra .  Solutions to many problems can be expressed using the SVD and its components .  We won ’ t go into too much detail about this algorithm or its applications (you could read  our paper ) .  Instead, we will focus on how to implement the algorithm in BitSAD .  First, let ’ s take a look at the power iteration itself . The algorithm above is repeated for   iterations .   ,  , and   are all matrices or vectors, and   denotes the L2 - norm of a vector .  While this might seem very complex compared to our examples in the previous tutorials, BitSAD will make implementing these five steps easy .","id":"docs/tutorials/iterative-svd.html#power-iteration-for-svd"},{"body":"Keywords: name::Symbol : the name of the module (defaults to  nameof(fn) ) bitwidth::@NamedTuple{integral::Int, fractional::Int} : the maximum bit width in the circuit parameters::Dict{String, Number} : a map from the name of each parameter to its default value submodules::Vector{Type} : a list of submodule types dfg::MetaDiGraph{Int, Float64} : a data flow graph representing the circuit to be generated handlers::Dict{Operation, AbstractHandler} : a map from operation type to a hardware generation handler and state","id":"docstrings/BitSAD.CircuitModule.html#keywords"},{"body":"Creating a custom  SBitstream  operator In most of the tutorials, we ’ ve discussed writing functions of  SBitstream s, simulating those functions, and generating hardware for those functions .  This already covers a large variety of circuits, but in some cases, your circuit will need an custom operator that is not already defined in BitSAD .  Defining this operator so that it is simulatable and synthesizable like all the standard BitSAD operators is what this how - to will cover .  The entire process requires three pieces: Define a Julia function Associate the function with a simulator Associate the function with a hardware handler","id":"docs/how-tos/custom-sbitstream.html#creating-a-custom-sbitstream-operator"},{"body":"public   estimate!   —   function Push  b  into the  buffer  and return the current  estimate .","id":"docstrings/BitSAD.estimate!.html"},{"body":"private   simulator   —   function Return a simulatable  Ghost.Tape  for  f(args...) . End - users should use  simulatable  instead .","id":"docstrings/BitSAD.simulator.html"},{"body":"Complex functions of bitstreams So far, we worked with relatively simple functions of  SBitstream s that could be simulated and mapped to hardware manually .  In this tutorial, we will look at a more complex example, the power iteration singular value decomposition algorithm of a matrix .","id":"docs/tutorials/iterative-svd.html#complex-functions-of-bitstreams"},{"body":"Creating and working with bitstreams Creating a stochastic bitstream variable is straightforward: Here  x  is a stochastic bitstream representing the real number 0 . 1 .  We can do arithemetic with  SBitstream s: We can see that the result of  x + y  has an encoded value of  0.4 == 0.1 + 0.3 .  This can be taken further to write more complex functions of bitstreams:","id":"docs/tutorials/getting-started.html#creating-and-working-with-bitstreams"},{"body":"private   netsize   —   function Return the net size of  x . Like  Base.size , but it expands scalars and vectors to 2D sizes (e . g .   (1, 1) ) .","id":"docstrings/BitSAD.netsize.html"},{"body":"private   show_simulatable   —   function Print the simulatable program returned by  simulatable .","id":"docstrings/BitSAD.show_simulatable.html"},{"body":"Generating hardware for the power iteration Since our function is working at the bit - level, the next step is to generate Verilog for it . This is great, but we see that BitSAD interprets  sqrt(size(A, 1))  in our function as a constant .  In hardware, we could not compute the array size on the fly .  Instead, it would be a parameter of the circuit .  To replicate this behavior in BitSAD, we need to use a struct . Here, we created the  PowerIteration  struct which can be instantiated with the matrix size like  PowerIteration(m, n) .  We made the struct callable, and the body of the function is nearly the same as  power_iteration .   The only difference is that we use  circuit.scalew  instead of  sqrt(size(A, 1))  (same for the number of columns) .  We can generate harware for  PowerIteration  just like we did for regular functions, but now any accesses to the fields of the  PowerIteration  struct will be treated like parameters in Verilog . We can see that the generated Verilog contains  scalew  and  scalez  as parameters, and BitSAD automatically determined the fixed point binary values for them .","id":"docs/tutorials/iterative-svd.html#generating-hardware-for-the-power-iteration"},{"body":"private   SSignedDivider   —   struct A signed stochastic bitstream divide operator .","id":"docstrings/BitSAD.SSignedDivider.html"},{"body":"private   value   —   function Return the underlying Julia value that  x  represents .","id":"docstrings/BitSAD.value.html"},{"body":"The result,  z , has an encoded value of  0.15 = 0.3 * 0.5 .  Recall that stochastic bitstreams encode the value in the mean of their underlying distributions .  Any function on applied to  SBitstream s is implying a function over their means .  Thus, We can verify this in BitSAD too . So far, we haven ’ t described how this multiplication is actually executed on hardware .  Certainly, multiplying the floating point means then drawing from the resulting distribution would be no better than traditional arithemetic .  Stochastic computing takes advantage of the fact that   and   are independent to note that In other words, we can multiply the samples at step  t  from each sequence to create a new sequence .  The mean of this new sequence should match  .  Let ’ s see it in action . We used a helper function,  multiply_sbit  to multiply the positive and negative channel of each  SBit  separately .  This resulted in a new  SBit ,  zbit , which we pushed onto  z .  When we take the empirical average of all these  zbit s, we see that it is close to the true mean of  z . Hopefully, you can now see why stochastic computing can be so resource efficient .  Each channel of  multiply_sbit  only needed to multiply two 1 - bit numbers .  This can be done with a single AND gate . In the next tutorial, you ’ ll see how to automate the  SBit - level simulation we did above, and how to generate synthesizable hardware from a Julia function .","id":"docs/tutorials/sbitstream.html#sbitstream-101-z"},{"body":"Defining the Julia operator Let ’ s start with the easiest step  —  defining what we want our operator to do to the encoded value of the  SBitstream  (this is not the bit - level behavior ! ) .  We ’ ll make up a non - sensical operator here,  addtimes(x, y) , which adds two  SBitstream s then multiplies the result by the first  SBitstream . It looks like the encoded floating point value for our function is correct .","id":"docs/how-tos/custom-sbitstream.html#defining-the-julia-operator"},{"body":"private   SSignedMatMultiplier   —   struct A stochastic bitstream matrix multiply operator .","id":"docstrings/BitSAD.SSignedMatMultiplier.html"},{"body":"public   SBitstream   —   parametric type A stochastic bitstream that represents a real (floating - point) number between  [ - 1, 1 ] . You can turn of saturation warnings by calling BitSAD.set_saturation_verbosity(:none) . Turn them back on by calling BitSAD.set_saturation_verbosity(:full) . Fields: bits::Vector{SBit} : the underlying bitstream value::T : the underlying floating - point number being represented","id":"docstrings/BitSAD.SBitstream.html"},{"body":"Generating hardware With BitSAD, we ’ ve been able to create functions on stochastic bitstreams, and we verified that they should work at the bit - level .  The next step is to generate hardware for these functions !  BitSAD can take any Julia function and generate synthesizable Verilog code . Let ’ s start by creating hardware for  f . We do this by calling  generatehw  which has a similar syntax to  simulatable .  It returned two values,  f_verilog  and  f_circuit .   f_verilog  is a  String  of the Verilog code .  You can write this to disk or examine it in the Julia REPL . We see that each net has a  “ _ p ”  and  “ _ m ”  appended for  “ plus ”  and  “ minus . ”  Recall, this is because  SBitstream s are signed and represented by two channels .  Handling these channels correctly to produce a single  SBitstream  as the output is why our hardware is so much more complex than a single AND gate .  BitSAD was created to automate this complexity away .","id":"docs/tutorials/simulation-and-hardware.html#generating-hardware"},{"body":"private   SSquareRoot   —   struct A stochastic bitstream square root operator .","id":"docstrings/BitSAD.SSquareRoot.html"},{"body":"Fields popmap : a map from the original call to the simulated bit computation opmap : a  “ reverse ”  map from a function + arguments to returned  Ghost.Variable","id":"docstrings/BitSAD.SimulatableContext.html#fields"},{"body":"Applying decorrelation Recall from  stochastic bitstreams 101  that stochastic computing operators exploit the statistical independence of their inputs .  But in the previous section, we can see clearly that  hsim  does not pass independent inputs to the  SSignedMultiplier  (it ’ s the  exact same  bit ! ) .  So, we should expect incorrect results Note that the algorithmic - level of  h  had no issues ( float(z) == 0.64 ), but the bit - level output has measurable error .  BitSAD was designed to make spotting issues that appear at the hardware - level easier .  How can we fix this? In stochastic computing circuits, we can  decorrelate  bitstreams to make them independent .","id":"docs/tutorials/simulation-and-hardware.html#applying-decorrelation"},{"body":"private   name   —   function Return the net name for  x . This can be a SystemVerilog constant expression .","id":"docstrings/BitSAD.name.html"},{"body":"private   Net   —   parametric type Create a new multi - dimensional SystemVerilog net (for  x ) .","id":"docstrings/BitSAD.Net.html"},{"body":"private   gethandler   —   function Return an instance of the hardware handler for the call of type  ftype on arguments of types  argtypes . isbroadcast  is true if the call is a broadcasted call . Custom operators should overload this function to generate SystemVerilog for calls to the operator . See also  BitSAD.init_state .","id":"docstrings/BitSAD.gethandler.html"},{"body":"private   SL2Normer   —   struct A stochastic bitstream L2 - norm operator .","id":"docstrings/BitSAD.SL2Normer.html"},{"body":"private   SSignedDecorrelator   —   struct A stochastic bitstream decorrelator .","id":"docstrings/BitSAD.SSignedDecorrelator.html"},{"body":"Stochastic bitstreams 101 A stochastic bitstreams,  , is a sequence of samples from a Bernoulli distribution: where   is the underlying value being encoded .  Stochastic bitstreams are the data format used in  stochastic computing . So,  why stochastic bitstreams?  You can refer to  Gaines ’  original work  on the topic, but in short, stochastic computing systems tend to be much more area and power efficient compared to traditional binary systems .  The reason for this is that any hardware operation on stochastic bitstreams must only process a single bit at a time, and this can often be done in a  “ streaming ”  fashion (eliminating the need for sequential logic) . Take multiplication as an example .  For numbers represented in floating point binary, multiplication can be an expensive hardware operation .  In many ultra - low power systems, floating - point multiplication is evaluated over multiple clock cycles with integer arithemetic units .  In contrast, a stochastic computing multiplier is a single AND gate .  In the next section, you ’ ll see why this is the case .","id":"docs/tutorials/sbitstream.html#stochastic-bitstreams-101"},{"body":"Simulating and generating hardware in BitSAD In  stochastic bitstreams 101 , we multiplied two  SBitstream s manually in a loop .  This can be cumbersome for complex functions involving many inputs and outputs .  A key feature of BitSAD is the automation of this step which we will explore in the following tutorial .  As a bonus, you ’ ll see how the same principles enable automatic  Verilog  generation to create hardware for your functions .","id":"docs/tutorials/simulation-and-hardware.html#simulating-and-generating-hardware-in-bitsad"},{"body":"private   is_simulatable_primitive   —   function Return true if calling a callable of type  ftype  on arguments of types  argtypes  is a BitSAD simulatable primitive operator . Custom operators should overload  BitSAD.is_trace_primitive  before this function . is_simulatable_primitive  should only be overloaded if the primitive behavior is different for only simulation .  Defaults to  is_trace_primitive .","id":"docstrings/BitSAD.is_simulatable_primitive.html"},{"body":"Associating  addtimes  with a hardware handler When BitSAD generates hardware, it uses the same program tracing functionality used in simulation to create a data - flow graph (DFG) of the program .  Then it applies a series of transformation passes on the graph to apply optimizations .  Finally, it traverses the graph from inputs to outputs, maintaining a  BitSAD.Netlist  along the way .  At each node, it invokes the  hardware handler  associated with that node .  A hardware handler is responsible for generating the SystemVerilog instantiation code for each node of a certain type .  For example, the  BitSAD.SAddHandler  writes the SystemVerilog code to instantiate every  +  operation in the DFG .  The reason a single handler instance is called repeatedly to generate each piece of SystemVerilog is so that the handler can ensure that SystemVerilog instance naming is unique . Suppose we have the following SystemVerilog module: Let ’ s write a handler in BitSAD that instantiates a new  AddTimes  whenever  addtimes  is encountered in the DFG . Our  SAddTimesHandler  (stochastic  addtimes  handler) has some state associated with it .  We use this to keep track of how many instances of the Verilog module we have created .  The handler is callable according to the handler interface which accepts the arguments: buffer : the IO stream to write our SystemVerilog to netlist : the current circuit  Netlist state : the handler state inputs : a  Netlist  of inputs outputs : a  Netlist  of outputs By convention, BitSAD represents  SBitstream  nets as the net ’ s name with  “ _ p ”  or  “ _ m ”  appended .  We also used the  BitSAD.handle_broadcast_name  to adjust the input names in the presence of a broadcast .  Writing to  buffer  is the important piece of code here .  This is the SystemVerilog code that will be produced for each  addtimes .  You can see we used the  id  field to name the module instance uniquely, and we passed in the standard  CLK  and  nRST  signals . At this stage, like our simulator, BitSAD still does not know how to associate nodes in the DFG with our handler .  We extend a similar interface to the simulator . The first  Bool  argument is  true  when the operation is broadcasted and  false  if not .  If your operator does not deal with broadcasting, then you can ignore this argument . We don ’ t need to redefine this operation as primitive, since we already extended  BitSAD.is_trace_primitive .  If you want, you can define  BitSAD.is_simulatable_primitive  and  BitSAD.is_hardware_primitive  separately (by default they call  BitSAD.is_trace_primitive ) . Let ’ s generate some hardware ! And that ’ s all there is to creating custom operators in BitSAD for  SBitstream s .","id":"docs/how-tos/custom-sbitstream.html#associating-addtimes-with-a-hardware-handler"},{"body":"Simulating bitstreams You may have noticed that the printing of  result  above had the phrase  “ 0 bits enqueue . ”  Until now, the value of each  SBitstream  (e . g .   float(result) ) is the exact mean of the underlying Bernoulli distribution .  This is not how functions of bitstreams are computed in hardware .  In reality, the hardware would process a sample drawn from each of the input bitstreams .  You can simulate this behavior with BitSAD: simulatable  creates a simulation object which can be called just like our original function  h  (except we must pass in  h  as the first argument) .  We simulate  num_samples  evaluations, drawing from the distributions for  x ,  y , and  z , simulating the hardware on those samples, and pushing the resulting output sample onto  result .  Finally, we see that the emprical estimate of  result  is quite close to the true mean and that  result  now contains 10,000 samples in queue .","id":"docs/tutorials/getting-started.html#simulating-bitstreams"},{"body":"Operations on  SBitstream s So far, we have not computed any meaningful results with BitSAD .  Let ’ s go back to the multiplication example and try to multiply two  SBitstream s .","id":"docs/tutorials/sbitstream.html#operations-on-sbitstreams"},{"body":"private   SimulatableContext   —   struct Used by BitSAD ’ s simulation engine to track bit - level returns and previously transformed calls .","id":"docstrings/BitSAD.SimulatableContext.html"},{"body":"Associating  addtimes  with a simulator Next, we need to be able to simulate  addtimes  at the bit - level .  To do this, we ’ ll define a simulator  —  a struct that operates on  SBit s and stores stateful information for this operation .  We ’ ll make use of the existing simulators in BitSAD to do this, which you can do in your code, or you can define a simulator completely from scratch .  All that matters is that your simulator can be called on  (x::SBit, y::SBit) . So far, BitSAD doesn ’ t know that it should map simulated calls to  addtimes  to an instance of  AddTimeser .  To do this, we need to  extend  the simulator interface . Now, whenever BitSAD sees a function call in a simulated program that matches our  BitSAD.is_trace_primitive  signature, it will call  BitSAD.getsimulator  to create a new simulator instance, and it will forward the popped bits to that simulator . We implemented the broadcasted simulator for  addtimes  as many  AddTimesers  in the same shape as the broadcasted arrays  x  and  y .  You can also create a simulator specifically for broadcasted calls that operates on arrays of  SBit s .  Instead of returning an array of simulators, you would return a single instance of this special broadcast simulator .  BitSAD will understand either option and pass the popped bits appropriately . Let ’ s see if our simulator works .","id":"docs/how-tos/custom-sbitstream.html#associating-addtimes-with-a-simulator"},{"body":"public   generate   —   function Generate  T  samples of the bitstream,  s . Add them to the queue for  generate! , otherwise return the vector of bits .","id":"docstrings/BitSAD.generate.html"},{"body":"public   generatehw   —   function Generate a SystemVerilog module named  top  for  f(args...)  as a circuit . Apply  transforms  to the circuit before generating the SystemVerilog .","id":"docstrings/BitSAD.generatehw.html"},{"body":"public   estimate   —   function Get the empirical mean of the bits in  buffer / s","id":"docstrings/BitSAD.estimate.html"},{"body":"BitSAD Dev CI BitSAD is a domain - specific framework for bitstream computing .  It aims to provide a general purpose linear algebra interface for writing algorithms that can be mapped to bitstream computing hardware .  Programs written in BitSAD can be turned into synthesizable, verified SystemVerilog code . See  CITATION . bib  for how to cite BitSAD if you use it in your research . Note:  Deterministic bitstreams are temporarily unavailable .","id":"README.html#bitsad"},{"body":"private   transform!   —   function Transform  tape  by applying  f  to each entry in the tape . f(tape.ctx, entry)  cannot manipulate  tape  directly . Instead,  f  should return a tuple of the form  ([calls...], idx) where  [calls...]  is a vector of tape entries that should replace  entry . idx  specifies that references to  entry  in  tape  should be rebound to calls[idx] . If  calls  is empty, then  entry  is deleted from the tape, and references to it are rebound to  idx . Note that if  entry isa Ghost.Input , then it cannot be deleted from  tape . fctx(tape.ctx, calls)  can be used to update  tape.ctx . calls  is the same list of entries returned by  f  except that the ID for each entry in  calls  is the ID  after  being rebound in  tape . If  calls  was empty, then  fctx  is not called . If not specified,  fctx  is a no - op .","id":"docstrings/BitSAD.transform!.html"},{"body":"private   SSignedFixedGainDivider   —   struct A stochastic bitstream fixed gain divide operator .","id":"docstrings/BitSAD.SSignedFixedGainDivider.html"},{"body":"Single evalutaion When writing software, it is reasonable to execute the same function twice on the same set of inputs . h  calls  g(x, y)  twice, and as we can see it causes no issues when running the code .  In hardware,  g  is a stateful operator, so it cannot be called twice, since multiple invocations will produce different outputs .  Instead, we want to re - use the first evaluation of  g(x, y) .  BitSAD does this automatically . Examining the compiled function, we see that only a single  SSignedAdder  is invoked on the inputs .  The same resulting bit,  x7 , is passed to the final  SSignedMultiplier .","id":"docs/tutorials/simulation-and-hardware.html#single-evalutaion"},{"body":"private   getsimulator   —   function Return a new instance of the simulatable operator for  f(args...) . Custom operators should overload this function and define  BitSAD.is_simulatable_primitive .","id":"docstrings/BitSAD.getsimulator.html"}]