[{"body":"private   SSignedSubtractor   —   struct A signed stochastic bitstream subtract operator .","id":"docstrings/BitSAD.SSignedSubtractor.html"},{"body":"public   observe   —   function Examine the most recent bit added to the stream without removing it . Fields: s::AbstractBitstream : the bitstream object","id":"docstrings/BitSAD.observe.html"},{"body":"Installation You can install BitSAD by opening a Julia REPL and entering (note that the  ]  indicates  Pkg mode ):","id":"README.html#installation"},{"body":"private   SSignedAdder   —   struct A signed stochastic bitstream add operator .","id":"docstrings/BitSAD.SSignedAdder.html"},{"body":"Quick start BitSAD allows you to write programs that operate on bitstreams .  A bitstream is a sequence of single bit values that represents some data .  The following tutorial will help you get started with BitSAD if you already have familiarity with bitstream computing .  For a more detailed tutorial, see  stochastic bitstreams 101 . Currently, BitSAD defines  SBitstream  to refer to bit sequences found in  stochastic computing .  Such bitstreams are modeled as a Bernoulli sequence whose mean is the true number being encoded .","id":"docs/tutorials/getting-started.html#quick-start"},{"body":"Basics of stochastic bitstreams First, let ’ s try creating a stochastic bitstream . Here, we created a  SBitstream  (the type in BitSAD for stochastic bitstreams) encoding the real value 0 . 3 .   SBitstream  will keep track of the mean of the Bernoulli distribution, which we can recover with  float . You ’ ll also notice that there were  “ 0 bits enqueue ”  in  x .  This refers to the fact that the bitstream,  x , is a sequence of samples .  Currently, we have not drawn any samples from  x .  We can try that now: Now, we have a single sample,  xt , which is of type  SBit .  An  SBit  is a  “ stochastic bit ”  which is just a convenient alias for a  NamedTuple  with two parts  —  the positive part ( pos ) and the negative part ( neg ) . Wait, I thought stochastic bitstreams were a single bit sequence?  —  You (probably) Yes, in theory, but this definition means that we can only represent real numbers  .  In practice, we would like to represent signed numbers (though we still normalize them to  ) .  BitSAD uses a two - channel format for encoding signed numbers as two underlying bitstreams .  One channel is the positive part and the other is the negative part, such that Samples from these two separate channels are neatly packaged into a single  SBit  so that we can think of  SBitstream s as a sequence of  SBit s without having to worry too much about the underlying signed encoding scheme . If we want, we can even add  SBit s onto a  SBitstream . We see that  x  now has a single bit in queue .  For convenience, BitSAD provides  generate!  to pre - load a  SBitstream  with samples from the underlying distributions . Finally, we can see that the empirical average over the  SBit s in queue matches to encoded value quite closely .","id":"docs/tutorials/sbitstream.html#basics-of-stochastic-bitstreams"},{"body":"Name Module Visibility Category  length   BitSAD   public   function   pop!   BitSAD   public   function   push!   BitSAD   public   function   AbstractBitstream   BitSAD   public   type   Module   BitSAD   private   parametric type   SBitstream   BitSAD   public   parametric type   SL2Normer   BitSAD   private   struct   SSignedAdder   BitSAD   private   struct   SSignedDecorrelator   BitSAD   private   struct   SSignedDivider   BitSAD   private   struct   SSignedFixedGainDivider   BitSAD   private   struct   SSignedMatMultiplier   BitSAD   private   struct   SSignedMultiplier   BitSAD   private   struct   SSignedSubtractor   BitSAD   private   struct   SSquareRoot   BitSAD   private   struct   estimate!   BitSAD   public   function   estimate   BitSAD   public   function   generate   BitSAD   public   function   generateverilog   BitSAD   private   function   observe   BitSAD   public   function ","id":"docstrings.html#docstring-index"},{"body":"Define the power iteration function We begin by defining the five steps as a plain function in Julia: The function  power_iteration  is almost an exact copy of the mathematical algorithm, except we do some additional scaling to  w  and  z .  We ’ ll see why in a moment .  For now, let ’ s test it on a random matrix to see if it works as expected . Unfortunately, our result is incorrect, but we can see that BitSAD reported saturation occuring several times .  Let ’ s try this again, but now, we ’ ll pre - scale  A  so that none of the operations in the algorithm saturate (more details on the choice of scaling are in  our paper ) .  Note that this is also the reason why we scaled  w  and  z  in the original function (so that  norm(w)  did not saturate) . Without saturation, our results are more accurate .","id":"docs/tutorials/iterative-svd.html#define-the-power-iteration-function"},{"body":"Simulating the power iteration The test above only verified that the basic algorithm worked with the limited numeric range of stochastic bitstreams .  It did not verify that bit - level operations would converge as well .  Let ’ s try that next . Since we are simulating bits, we need to store the bits in order to compute an estimate of the current simulation output .  We use a  CircularBuffer  from DataStructures . jl to do this .  Additionally, in the previous section, we directly fed back the output,  v , as an input in the subsequent iteration .  Now,  v  is unstable during the first few iterations, so we initiate the simulation with 1,000 pre - computed samples of  v₀ .  Finally, we measure the output error using the formula Any valid SVD will satisfy this property .  Our error is how closely this property holds for our current estimates .  We chose to use this error to illustrate how  estimate!  can be used to mix floating point and bitstream computation .","id":"docs/tutorials/iterative-svd.html#simulating-the-power-iteration"},{"body":"private   SSignedMultiplier   —   struct A signed stochastic bitstream multiply operator .","id":"docstrings/BitSAD.SSignedMultiplier.html"},{"body":"Create a simulation nop A  “ nop ”  (or  “ no op ” ) is an operation that passes its inputs through unmodified .  A  simulation nop  is a function that is not traced by the BitSAD simulator .  Instead, that call stack is  “ passed through ”  unmodified .  Let ’ s look at a concrete example . If we look at the transformed simulation code for  h , we see that BitSAD recurses into the call stack of  f . Suppose instead of unwrapping the call to  f , we want the simulator to call  f  itself on the plain arguments .  We can do this with  BitSAD.@nosim . By declaring  f(x)  as a simulation nop, we prevent BitSAD from tracing into  any  call matching  f(::Any) .  Instead, BitSAD will call  f(x) . You can use type signatures to restrict which methods of a function are marked as simulation nops .  For example,  f(x::SBitstream)  will only prevent tracing into  f  when  typeof(x) <: SBitstream .  When no type signature is given, the argument type defaults to  Any . Notice that  f  is called on  x2  directly (i . e .  there is no call to  getbit ) .  Marking a call as a simulation nop bypasses the  getbit / setbit!  calls inserted by the simulator for  all  arguments .","id":"docs/how-tos/nosim.html#create-a-simulation-nop"},{"body":"Fields: m::Module : the module to generate netlist::Netlist : the netlist for the circuit being generated f : a closure with one argument (a netlist) that calls a runtime information extraction function c::Tuple{Module, Function} : the tuple returned by  @circuit dut : an instance of the circuit struct args : example arguments to circuit","id":"docstrings/BitSAD.generateverilog.html#fields"},{"body":"Simulating functions on  SBitstream s Suppose we have the following function,  f , which multiplies two  SBitstream s . We see that the output,  z , is similar to the  previous tutorial .  Instead of manually simulating the bit - level multiplication in  f , we can use  simulatable . fsim  is a Julia function that can be called similar to  f  (the exception being that  fsim  expects the first argument to be the function to simulate,  f ) . For static functions like  f , it may see redundant to pass  f  in .  But the simulated function can be a  callable struct  as well .  This means that you can modify the struct between invocations of the simulation object if you desire . BitSAD generates  fsim  by executing  f(x, y)  once and storing the program execution on a trace .  This trace gets transformed into a similar program except calls to operations are replaced by calls to simulators .  These simulators emulate the bit - level execution, similar to  multiply_sbit  from the previous tutorial . Let ’ s verify that  fsim  works like our manual simulation from before . What ’ s actually happening inside  fsim ? We can take a peek under the hood with  show_simulatable  which will print out the Julia function being compiled by BitSAD . Here, we see that  fsim  is a function that accepts two  SBitstream{Float64} s as input .  Walking through each step, we see: x3 = getbit(x2)  pops a sample from the first input (similarly,  x5 = getbit(x4) ) . The regular  *(x2, x4)  is called on our input  SBitstream s to produce the output  SBitstream ,  x6 . A simulator,  SSignedMultiplier  is called on the popped bits,  x3  and  x4 . The resulting  SBit ,  x7 , is pushed onto the output bitstream with  setbit!(x6, x7) . These four steps are the basic transformation applied to any simulatable operation on the trace .","id":"docs/tutorials/simulation-and-hardware.html#simulating-functions-on-sbitstreams"},{"body":"Power iteration for SVD The  singular value decomposition  (SVD) is a fundamental decomposition in linear algebra .  Solutions to many problems can be expressed using the SVD and its components .  We won ’ t go into too much detail about this algorithm or its applications (you could read  our paper ) .  Instead, we will focus on how to implement the algorithm in BitSAD .  First, let ’ s take a look at the power iteration itself . The algorithm above is repeated for   iterations .   ,  , and   are all matrices or vectors, and   denotes the L2 - norm of a vector .  While this might seem very complex compared to our examples in the previous tutorials, BitSAD will make implementing these five steps easy .","id":"docs/tutorials/iterative-svd.html#power-iteration-for-svd"},{"body":"Creating a custom  SBitstream  operator In most of the tutorials, we ’ ve discussed writing functions of  SBitstream s, simulating those functions, and generating hardware for those functions .  This already covers a large variety of circuits, but in some cases, your circuit will need an custom operator that is not already defined in BitSAD .  Defining this operator so that it is simulatable and synthesizable like all the standard BitSAD operators is what this how - to will cover .  The entire process requires three pieces: Define a Julia function Associate the function with a simulator Associate the function with a hardware handler","id":"docs/how-tos/custom-sbitstream.html#creating-a-custom-sbitstream-operator"},{"body":"public   estimate!   —   function Push  b  into the  buffer  and return the current  estimate .","id":"docstrings/BitSAD.estimate!.html"},{"body":"Complex functions of bitstreams So far, we worked with relatively simple functions of  SBitstream s that could be simulated and mapped to hardware manually .  In this tutorial, we will look at a more complex example, the power iteration singular value decomposition algorithm of a matrix .","id":"docs/tutorials/iterative-svd.html#complex-functions-of-bitstreams"},{"body":"Creating and working with bitstreams Creating a stochastic bitstream variable is straightforward: Here  x  is a stochastic bitstream representing the real number 0 . 1 .  We can do arithemetic with  SBitstream s: We can see that the result of  x + y  has an encoded value of  0.4 == 0.1 + 0.3 .  This can be taken further to write more complex functions of bitstreams:","id":"docs/tutorials/getting-started.html#creating-and-working-with-bitstreams"},{"body":"public   pop!   —   function Pop a bit from bitstream  s . Fields: s::AbstractBitstream : the bitstream object","id":"docstrings/Base.pop!.html"},{"body":"Generating hardware for the power iteration Since our function is working at the bit - level, the next step is to generate Verilog for it .  Unfortunately, using  generatehw  directly results in an error . BitSAD does not know how to interpret  size(A, 1)  in our function .  In hardware, we would not compute the array size on the fly .  Instead, it would be a parameter of the circuit .  To replicate this behavior in BitSAD, we need to use a struct . Here, we created the  PowerIteration  struct which can be instantiated with the matrix size like  PowerIteration(m, n) .  We made the struct callable, and the body of the function is nearly the same as  power_iteration .   The only difference is that we use  circuit.scalew  instead of  sqrt(size(A, 1))  (same for the number of columns) .  We can generate harware for  PowerIteration  just like we did for regular functions, but now any accesses to the fields of the  PowerIteration  struct will be treated like parameters in Verilog . We can see that the generated Verilog contains  scalew  and  scalez  as parameters, and BitSAD automatically determined the fixed point binary values for them .","id":"docs/tutorials/iterative-svd.html#generating-hardware-for-the-power-iteration"},{"body":"private   Module   —   parametric type A data structure to store information to generate hardware for a circuit . This structure can be manually modified if needed but typically  @circuit is used to auto - populate it . Hardware generation traverses  dfg  and uses  handlers  to generate Verilog strings .","id":"docstrings/BitSAD.Module.html"},{"body":"private   SSignedDivider   —   struct A signed stochastic bitstream divide operator .","id":"docstrings/BitSAD.SSignedDivider.html"},{"body":"The result,  z , has an encoded value of  0.15 = 0.3 * 0.5 .  Recall that stochastic bitstreams encode the value in the mean of their underlying distributions .  Any function on applied to  SBitstream s is implying a function over their means .  Thus, We can verify this in BitSAD too . So far, we haven ’ t described how this multiplication is actually executed on hardware .  Certainly, multiplying the floating point means then drawing from the resulting distribution would be no better than traditional arithemetic .  Stochastic computing takes advantage of the fact that   and   are independent to note that In other words, we can multiply the samples at step  t  from each sequence to create a new sequence .  The mean of this new sequence should match  .  Let ’ s see it in action . We used a helper function,  multiply_sbit  to multiply the positive and negative channel of each  SBit  separately .  This resulted in a new  SBit ,  zbit , which we pushed onto  z .  When we take the empirical average of all these  zbit s, we see that it is close to the true mean of  z . Hopefully, you can now see why stochastic computing can be so resource efficient .  Each channel of  multiply_sbit  only needed to multiply two 1 - bit numbers .  This can be done with a single AND gate . In the next tutorial, you ’ ll see how to automate the  SBit - level simulation we did above, and how to generate synthesizable hardware from a Julia function .","id":"docs/tutorials/sbitstream.html#sbitstream-101-z"},{"body":"Defining the Julia operator Let ’ s start with the easiest step  —  defining what we want our operator to do to the encoded value of the  SBitstream  (this is not the bit - level behavior ! ) .  We ’ ll make up a non - sensical operator here,  addtimes(x, y) , which adds two  SBitstream s then multiplies the result by the first  SBitstream . It looks like the encoded floating point value for our function is correct .","id":"docs/how-tos/custom-sbitstream.html#defining-the-julia-operator"},{"body":"private   SSignedMatMultiplier   —   struct A stochastic bitstream matrix multiply operator .","id":"docstrings/BitSAD.SSignedMatMultiplier.html"},{"body":"public   SBitstream   —   parametric type A stochastic bitstream that represents a real (floating - point) number between  [ - 1, 1 ] . Fields: bits::Vector{SBit} : the underlying bitstream value::Float64 : the underlying floating - point number being represented","id":"docstrings/BitSAD.SBitstream.html"},{"body":"Fields: name::Symbol : the name of the module parameters::Dict{Symbol, Number} : a map from the name of each parameter to its default value submodules::Vector{Type} : a list of submodule types dfg::MetaDiGraph{Int, Float64} : a data flow graph representing the circuit to be generated handlers::Dict{Operation, AbstractHandler} : a map from operation type to a hardware generation handler . See also:  HW . generate","id":"docstrings/BitSAD.Module.html#fields"},{"body":"public   length   —   function Return the number of bits in  s .","id":"docstrings/Base.length.html"},{"body":"Generating hardware With BitSAD, we ’ ve been able to create functions on stochastic bitstreams, and we verified that they should work at the bit - level .  The next step is to generate hardware for these functions !  BitSAD can take any Julia function and generate synthesizable Verilog code . Let ’ s start by creating hardware for  f . We do this by calling  generatehw  which has a similar syntax to  simulatable .  It returned two values,  f_verilog  and  f_circuit .   f_verilog  is a  String  of the Verilog code .  You can write this to disk or examine it in the Julia REPL . That ’ s a lot of Verilog for a simple multiply !  We see that each net has a  “ _ p ”  and  “ _ m ”  appended for  “ plus ”  and  “ minus . ”  Recall, this is because  SBitstream s are signed and represented by two channels .  Handling these channels correctly to produce a single  SBitstream  as the output is why our hardware is so much more complex than a single AND gate .  BitSAD was created to automate this complexity away .","id":"docs/tutorials/simulation-and-hardware.html#generating-hardware"},{"body":"private   generateverilog   —   function Generate the Verilog implementation of the module . Users will most likely call the last method form above .","id":"docstrings/BitSAD.generateverilog.html"},{"body":"private   SSquareRoot   —   struct A stochastic bitstream square root operator .","id":"docstrings/BitSAD.SSquareRoot.html"},{"body":"Applying decorrelation Recall from  stochastic bitstreams 101  that stochastic computing operators exploit the statistical independence of their inputs .  But in the previous section, we can see clearly that  hsim  does not pass independent inputs to the  SSignedMultiplier  (it ’ s the  exact same  bit ! ) .  So, we should expect incorrect results Note that the algorithmic - level of  h  had no issues ( float(z) == 0.64 ), but the bit - level output has measurable error .  BitSAD was designed to make spotting issues that appear at the hardware - level easier .  How can we fix this? In stochastic computing circuits, we can  decorrelate  bitstreams to make them independent .","id":"docs/tutorials/simulation-and-hardware.html#applying-decorrelation"},{"body":"private   SL2Normer   —   struct A stochastic bitstream L2 - norm operator .","id":"docstrings/BitSAD.SL2Normer.html"},{"body":"private   SSignedDecorrelator   —   struct A stochastic bitstream decorrelator .","id":"docstrings/BitSAD.SSignedDecorrelator.html"},{"body":"Stochastic bitstreams 101 A stochastic bitstreams,  , is a sequence of samples from a Bernoulli distribution: where   is the underlying value being encoded .  Stochastic bitstreams are the data format used in  stochastic computing . So,  why stochastic bitstreams?  You can refer to  Gaines ’  original work  on the topic, but in short, stochastic computing systems tend to be much more area and power efficient compared to traditional binary systems .  The reason for this is that any hardware operation on stochastic bitstreams must only process a single bit at a time, and this can often be done in a  “ streaming ”  fashion (eliminating the need for sequential logic) . Take multiplication as an example .  For numbers represented in floating point binary, multiplication can be an expensive hardware operation .  In many ultra - low power systems, floating - point multiplication is evaluated over multiple clock cycles with integer arithemetic units .  In contrast, a stochastic computing multiplier is a single AND gate .  In the next section, you ’ ll see why this is the case .","id":"docs/tutorials/sbitstream.html#stochastic-bitstreams-101"},{"body":"Simulating and generating hardware in BitSAD In  stochastic bitstreams 101 , we multiplied two  SBitstream s manually in a loop .  This can be cumbersome for complex functions involving many inputs and outputs .  A key feature of BitSAD is the automation of this step which we will explore in the following tutorial .  As a bonus, you ’ ll see how the same principles enable automatic  Verilog  generation to create hardware for your functions .","id":"docs/tutorials/simulation-and-hardware.html#simulating-and-generating-hardware-in-bitsad"},{"body":"Associating  addtimes  with a hardware handler When BitSAD generates hardware, it uses the same program tracing functionality used in simulation to create a data - flow graph (DFG) of the program .  Then it applies a series of transformation passes on the graph to apply optimizations .  Finally, it traverses the graph from inputs to outputs, maintaining a  BitSAD.Netlist  along the way .  At each node, it invokes the  hardware handler  associated with that node .  A hardware handler is responsible for generating the Verilog instantiation code for each node of a certain type .  For example, the  BitSAD.SAddHandler  writes the Verilog code to instantiate every  +  operation in the DFG .  The reason a single handler instance is called repeatedly to generate each piece of Verilog is so that the handler can ensure that Verilog instance naming is unique . Suppose we have the following Verilog module: Let ’ s write a handler in BitSAD that instantiates a new  AddTimes  whenever  addtimes  is encountered in the DFG . Our  SAddTimesHandler  (stochastic  addtimes  handler) contains an  id  field .  We use this to keep track of how many instances of the Verilog module we have created .  The handler is callable according to the handler interface which accepts three arguments  —  a  Netlist , a vector of input  Net s, and a vector of output  Net s .  We use the  BitSAD.setsigned!  function to mark the inputs and outputs as signed .  This tells BitSAD that the input/output is actually two wires in Verilog (one for the positive channel and one for the negative channel) .  By convention, BitSAD represents this as the net ’ s name with  “ _ p ”  or  “ _ m ”  appended .  We also used the  BitSAD.handle_broadcast_name  to adjust the input names in the presence of a broadcast .  Assigning  outstring  is the important piece of code here .  This is the Verilog code that will be produced for each  addtimes .  You can see we used the  id  field to name the module instance uniquely, and we passed in the standard  CLK  and  nRST  signals . At this stage, like our simulator, BitSAD still does not know how to associate nodes in the DFG with our handler .  We extend a similar interface to the simulator . The first  Bool  argument is  true  when the operation is broadcasted and  false  if not .  If your operator does not deal with broadcasting, then you can omit this argument . We don ’ t need to redefine this operation as primitive, since we already extended  BitSAD.is_trace_primitive .  If you want, you can define  BitSAD.is_simulatable_primitive  and  BitSAD.is_hardware_primitive  separately (by default they call  BitSAD.is_trace_primitive ) . Let ’ s generate some hardware ! And that ’ s all there is to creating custom operators in BitSAD for  SBitstream s .","id":"docs/how-tos/custom-sbitstream.html#associating-addtimes-with-a-hardware-handler"},{"body":"Simulating bitstreams You may have noticed that the printing of  result  above had the phrase  “ 0 bits enqueue . ”  Until now, the value of each  SBitstream  (e . g .   float(result) ) is the exact mean of the underlying Bernoulli distribution .  This is not how functions of bitstreams are computed in hardware .  In reality, the hardware would process a sample drawn from each of the input bitstreams .  You can simulate this behavior with BitSAD: simulatable  creates a simulation object which can be called just like our original function  h  (except we must pass in  h  as the first argument) .  We simulate  num_samples  evaluations, drawing from the distributions for  x ,  y , and  z , simulating the hardware on those samples, and pushing the resulting output sample onto  result .  Finally, we see that the emprical estimate of  result  is quite close to the true mean and that  result  now contains 10,000 samples in queue .","id":"docs/tutorials/getting-started.html#simulating-bitstreams"},{"body":"public   AbstractBitstream   —   type Inherit from this type to create a custom bitstream type .","id":"docstrings/BitSAD.AbstractBitstream.html"},{"body":"Operations on  SBitstream s So far, we have not computed any meaningful results with BitSAD .  Let ’ s go back to the multiplication example and try to multiply two  SBitstream s .","id":"docs/tutorials/sbitstream.html#operations-on-sbitstreams"},{"body":"Associating  addtimes  with a simulator Next, we need to be able to simulate  addtimes  at the bit - level .  To do this, we ’ ll define a simulator  —  a struct that operates on  SBit s and stores stateful information for this operation .  We ’ ll make use of the existing simulators in BitSAD to do this, which you can do in your code, or you can define a simulator completely from scratch .  All that matters is that your simulator can be called on  (x::SBit, y::SBit) . So far, BitSAD doesn ’ t know that it should map simulated calls to  addtimes  to an instance of  AddTimeser .  To do this, we need to  extend  the simulator interface . Now, whenever BitSAD sees a function call in a simulated program that matches our  BitSAD.is_trace_primitive  signature, it will call  BitSAD.getsimulator  to create a new simulator instance, and it will forward the popped bits to that simulator . We implemented the broadcasted simulator for  addtimes  as many  AddTimesers  in the same shape as the broadcasted arrays  x  and  y .  You can also create a simulator specifically for broadcasted calls that operates on arrays of  SBit s .  Instead of returning an array of simulators, you would return a single instance of this special broadcast simulator .  BitSAD will understand either option and pass the popped bits appropriately . Let ’ s see if our simulator works .","id":"docs/how-tos/custom-sbitstream.html#associating-addtimes-with-a-simulator"},{"body":"public   generate   —   function Generate  T  samples of the bitstream,  s . Add them to the queue for  generate! , otherwise return the vector of bits .","id":"docstrings/BitSAD.generate.html"},{"body":"public   estimate   —   function Get the empirical mean of the bits in  buffer / s","id":"docstrings/BitSAD.estimate.html"},{"body":"BitSAD Dev CI BitSAD is a domain - specific framework for bitstream computing .  It aims to provide a general purpose linear algebra interface for writing algorithms that can be mapped to bitstream computing hardware .  Programs written in BitSAD can be turned into synthesizable, verified Verilog code . See  CITATION . bib  for how to cite BitSAD if you use it in your research . Note:  Deterministic bitstreams are temporarily unavailable .","id":"README.html#bitsad"},{"body":"public   push!   —   function Push a bit(s)  b  onto bitstream  s . Fields: s::AbstractBitstream : the bitstream object b : the bit(s) to push onto the stream","id":"docstrings/Base.push!.html"},{"body":"private   SSignedFixedGainDivider   —   struct A stochastic bitstream fixed gain divide operator .","id":"docstrings/BitSAD.SSignedFixedGainDivider.html"},{"body":"Single evalutaion When writing software, it is reasonable to execute the same function twice on the same set of inputs . h  calls  g(x, y)  twice, and as we can see it causes no issues when running the code .  In hardware,  g  is a stateful operator, so it cannot be called twice, since multiple invocations will produce different outputs .  Instead, we want to re - use the first evaluation of  g(x, y) .  BitSAD does this automatically . Examining the compiled function, we see that only a single  SSignedAdder  is invoked on the inputs .  The same resulting bit,  x7 , is passed to the final  SSignedMultiplier .","id":"docs/tutorials/simulation-and-hardware.html#single-evalutaion"}]