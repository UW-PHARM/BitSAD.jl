<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="generator" content="Publish.jl" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="" />
    <title>BitSAD.jl</title>
    <link rel="stylesheet" href="..&#x2F;..&#x2F;normalize.css" />
    <link rel="stylesheet" href="..&#x2F;..&#x2F;tabulator_simple.min.css" />
    <link rel="stylesheet" href="..&#x2F;..&#x2F;publish.css" />
    <link rel="stylesheet" href="..&#x2F;..&#x2F;default.min.css" />
    <script src="..&#x2F;..&#x2F;versions.js"></script>
    <script src="..&#x2F;..&#x2F;lunr.js"></script>
    <script src="..&#x2F;..&#x2F;highlight.min.js"></script>
    <script src="..&#x2F;..&#x2F;tabulator.min.js"></script>
    <script src="..&#x2F;..&#x2F;julia.min.js"></script>
    <script src="..&#x2F;..&#x2F;julia-repl.min.js"></script>
    <script src="..&#x2F;..&#x2F;publish.js"></script>
    
</head>
<body>
    <div class="menu">
        <svg id="menu-toggler" title="Contents" onclick="toggleIndexPage();" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2 6C2 5.44772 2.44772 5 3 5H21C21.5523 5 22 5.44772 22 6C22 6.55228 21.5523 7 21 7H3C2.44772 7 2 6.55228 2 6Z" fill="currentColor" /><path d="M2 12.0322C2 11.4799 2.44772 11.0322 3 11.0322H21C21.5523 11.0322 22 11.4799 22 12.0322C22 12.5845 21.5523 13.0322 21 13.0322H3C2.44772 13.0322 2 12.5845 2 12.0322Z" fill="currentColor" /><path d="M3 17.0645C2.44772 17.0645 2 17.5122 2 18.0645C2 18.6167 2.44772 19.0645 3 19.0645H21C21.5523 19.0645 22 18.6167 22 18.0645C22 17.5122 21.5523 17.0645 21 17.0645H3Z" fill="currentColor" /></svg>
        <input id="search-input" placeholder="Search">
        <select id="version-selector"></select>
    </div>
    <main id="page"><article><h1 id="complex-functions-of-bitstreams"><a href="#complex-functions-of-bitstreams" class="anchor"></a>Complex functions of bitstreams</h1>
<p>So far, we worked with relatively simple functions of <code>SBitstream</code>s that could be simulated and mapped to hardware manually. In this tutorial, we will look at a more complex example, the power iteration singular value decomposition algorithm of a matrix.</p>
<h2 id="power-iteration-for-svd"><a href="#power-iteration-for-svd" class="anchor"></a>Power iteration for SVD</h2>
<p>The <a href="https://en.wikipedia.org/wiki/Singular_value_decomposition">singular value decomposition</a> (SVD) is a fundamental decomposition in linear algebra. Solutions to many problems can be expressed using the SVD and its components. We won’t go into too much detail about this algorithm or its applications (you could read <a href="https://dl.acm.org/doi/10.1145/3316482.3326355">our paper</a>). Instead, we will focus on how to implement the algorithm in BitSAD. First, let’s take a look at the power iteration itself.</p>
<div class="display-math tex">\[\begin{aligned}
\text{Step 1:} \qquad w_k & \gets A v_{k - 1} \\
\text{Step 2:} \qquad u_k & \gets w_k / \|w_k\|_2 \\
\text{Step 3:} \qquad z_k & \gets A^\top v_{k - 1} \\
\text{Step 4:} \qquad \sigma_k & \gets \|z_k\|_2 \\
\text{Step 5:} \qquad v_k & \gets z_k / \sigma_k
\end{aligned}\]</div>
<p>The algorithm above is repeated for <span class="math tex">\(T\)</span> iterations. <span class="math tex">\(A\)</span>, <span class="math tex">\(v_k\)</span>, and <span class="math tex">\(u_k\)</span> are all matrices or vectors, and <span class="math tex">\(\| \cdot \|_2\)</span> denotes the L2-norm of a vector. While this might seem very complex compared to our examples in the previous tutorials, BitSAD will make implementing these five steps easy.</p>
<h2 id="define-the-power-iteration-function"><a href="#define-the-power-iteration-function" class="anchor"></a>Define the power iteration function</h2>
<p>We begin by defining the five steps as a plain function in Julia:</p>
<pre><code cell="iterative-svd" class="language-julia">using BitSAD
using LinearAlgebra

function power_iteration(A::Matrix, v₀::Vector)
    w = A * v₀
    wscaled = w .÷ sqrt(size(A, 1))
    u = wscaled ./ norm(wscaled)

    z = permutedims(A) * u
    zscaled = z .÷ sqrt(size(A, 2))
    σ = norm(zscaled)
    v = zscaled ./ σ

    return u, v, σ
end
</code></pre>
<pre><code class="plaintext cell-output cell-result" class="language-plaintext">power_iteration (generic function with 1 method)</code></pre>
<p>The function <code>power_iteration</code> is almost an exact copy of the mathematical algorithm, except we do some additional scaling to <code>w</code> and <code>z</code>. We’ll see why in a moment. For now, let’s test it on a random matrix to see if it works as expected.</p>
<pre><code cell="iterative-svd" class="language-julia"># use a 2x2 matrix
m, n = (2, 2)

A_float = 2 .* rand(m, n) .- 1
v₀_float = rand(n)
v₀_float .= v₀_float ./ norm(v₀_float) # v should be a unit vector

# compute the SVD for the floating point A
svddecomp = svd(A_float)

A = SBitstream.(A_float)
v₀ = SBitstream.(v₀_float)

function run_power_iteration(A, v₀; T = 10)
    u = similar(A, size(A, 1))
    σ = 0.0
    v = v₀
    for k in 1:T
        u, v, σ = power_iteration(A, v)
    end

    return u, v, σ
end

u, v, σ = run_power_iteration(A, v₀)

println(&quot;u error: $(float.(u) - svddecomp.U[1, :])&quot;)
println(&quot;v error: $(float.(v) - svddecomp.V[1, :])&quot;)
println(&quot;σ error: $(float(σ) * sqrt(n) - svddecomp.S[1])&quot;)
</code></pre>
<pre><code class="plaintext cell-output cell-stream">u error: [-0.7320007677391142, 1.861229399087687]
v error: [-1.240072862161959, 3.032194250129905e-7]
σ error: -3.6759484345338933e-13
</code></pre>
<p>Unfortunately, our result is incorrect, but we can see that BitSAD reported saturation occuring several times. Let’s try this again, but now, we’ll pre-scale <code>A</code> so that none of the operations in the algorithm saturate (more details on the choice of scaling are in <a href="https://www.frontiersin.org/articles/10.3389/fnins.2018.00115/full">our paper</a>). Note that this is also the reason why we scaled <code>w</code> and <code>z</code> in the original function (so that <code>norm(w)</code> did not saturate).</p>
<pre><code cell="iterative-svd" class="language-julia">α = 2 * max(norm(A_float, Inf), norm(A_float, 1))
A_float .= A_float ./ α

A = SBitstream.(A_float)

u, v, σ = run_power_iteration(A, v₀)

println(&quot;u error: $(float.(u) - svddecomp.U[1, :])&quot;)
println(&quot;v error: $(float.(v) - svddecomp.V[1, :])&quot;)
println(&quot;σ error: $(float(σ) * α * sqrt(n) - svddecomp.S[1])&quot;)
</code></pre>
<pre><code class="plaintext cell-output cell-stream">u error: [-0.7320007677391143, 1.861229399087687]
v error: [-1.2400728621619592, 3.032194249019682e-7]
σ error: -3.6759484345338933e-13
</code></pre>
<p>Without saturation, our results are more accurate.</p>
<h2 id="simulating-the-power-iteration"><a href="#simulating-the-power-iteration" class="anchor"></a>Simulating the power iteration</h2>
<p>The test above only verified that the basic algorithm worked with the limited numeric range of stochastic bitstreams. It did not verify that bit-level operations would converge as well. Let’s try that next.</p>
<pre><code cell="iterative-svd" class="language-julia">using DataStructures

# simulate for more iterations
T = 5000

# record the error on each iteration
ϵ = zeros(T)

# record the most recent 5000 samples of each output
ubuffer = CircularBuffer{Vector{Int}}(5000)
vbuffer = CircularBuffer{Vector{Int}}(5000)
σbuffer = CircularBuffer{Int}(5000)

# generate T samples of A
# generate 1000 samples of v,
#  then switch to feeding v back into the algorithm
generate!.(A, T)
generate!.(v₀, 1000)

sim = simulatable(power_iteration, A, v₀)
for t in 1:T
    # evaluate module
    output = sim(power_iteration, A, v₀)

    # accumulate results in buffer
    global u = estimate!(ubuffer, output[1])
    global v = estimate!(vbuffer, output[2])
    global σ = estimate!(σbuffer, output[3])

    # feedback output
    (t &gt;= 1000) &amp;&amp; push!(v₀, pop!(decorrelate.(output[2])))

    # record loss
    ϵ[t] = norm(α * (A_float * v - u * σ * sqrt(n)))
end

u = estimate(ubuffer)
v = estimate(vbuffer)
σ = estimate(σbuffer) * α * sqrt(n)

println(&quot;final error: $(ϵ[end])&quot;)
</code></pre>
<pre><code class="plaintext cell-output cell-result" class="language-plaintext">LoadError(&quot;string&quot;, 17, MethodError(push!, (SBitstream(-0.030592660609778877), NamedTuple{(:pos, :neg), Tuple{Bool, Bool}}[(false, false), (false, false), (false, false), (false, false), (false, false), (false, false), (false, false), (false, false), (false, false), (false, false)  …  (false, false), (false, false), (false, false), (false, false), (false, false), (false, false), (false, false), (false, false), (false, false), (false, false)]), 0x0000000000008139))</code></pre>
<p>Since we are simulating bits, we need to store the bits in order to compute an estimate of the current simulation output. We use a <code>CircularBuffer</code> from DataStructures.jl to do this. Additionally, in the previous section, we directly fed back the output, <code>v</code>, as an input in the subsequent iteration. Now, <code>v</code> is unstable during the first few iterations, so we initiate the simulation with 1,000 pre-computed samples of <code>v₀</code>. Finally, we measure the output error using the formula</p>
<div class="display-math tex">\[Av = \sigma u\]</div>
<p>Any valid SVD will satisfy this property. Our error is how closely this property holds for our current estimates. We chose to use this error to illustrate how <a href="../../docstrings/BitSAD.estimate!.html"><code>estimate!</code></a> can be used to mix floating point and bitstream computation.</p>
<h2 id="generating-hardware-for-the-power-iteration"><a href="#generating-hardware-for-the-power-iteration" class="anchor"></a>Generating hardware for the power iteration</h2>
<p>Since our function is working at the bit-level, the next step is to generate Verilog for it. Unfortunately, using <a href="../../docstrings/BitSAD.generatehw.html"><code>generatehw</code></a> directly results in an error.</p>
<pre><code cell="iterative-svd" class="language-julia">try
    power_iteration_verilog, _ = generatehw(power_iteration, A, v₀)
catch e
    println(e)
end
</code></pre>
<pre><code class="plaintext cell-output cell-result" class="language-plaintext">(&quot;module power_iteration(CLK, nRST, net_2_p, net_2_m, net_3_p, net_3_m, net_22_p, net_22_m);\n\n\ninput CLK, nRST;\ninput  [3:0] net_2_p, net_2_m;\ninput  [1:0] net_3_p, net_3_m;\noutput  [1:0] net_22_p, net_22_m;\n\nwire  [1:0] net_4_p, net_4_m;\nwire   net_6;\nwire  [1:0] net_7_p, net_7_m;\nwire   net_10_p, net_10_m;\nwire  [1:0] net_11_p, net_11_m;\nwire  [3:0] net_14_p, net_14_m;\nwire  [1:0] net_15_p, net_15_m;\nwire   net_17;\nwire  [1:0] net_18_p, net_18_m;\nwire   net_21_p, net_21_m;\nwire  [1:0] mmult0_out_pp;\nwire  [1:0] mmult0_out_pm;\nwire  [1:0] mmult0_out_mp;\nwire  [1:0] mmult0_out_mm;\nwire  [1:0] mmult0_out_11;\nwire  [1:0] mmult0_out_12;\nwire  [1:0] mmult0_out_13;\nwire  [1:0] mmult0_out_14;\nwire  [1:0] div0_out_pp;\nwire  [1:0] div0_out_mp;\nwire  [1:0] mmult1_out_pp;\nwire  [1:0] mmult1_out_pm;\nwire  [1:0] mmult1_out_mp;\nwire  [1:0] mmult1_out_mm;\nwire  [1:0] mmult1_out_11;\nwire  [1:0] mmult1_out_12;\nwire  [1:0] mmult1_out_13;\nwire  [1:0] mmult1_out_14;\nwire  [1:0] div1_out_pp;\nwire  [1:0] div1_out_mp;\n\n// Autogenerated by BitSAD\n// BEGIN mmult0\nstoch_matrix_mult #(\n        .NUM_ROWS(2),\n        .NUM_MID(2),\n        .NUM_COLS(1)\n    ) mmult0_pp (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(net_2_p),\n        .B(net_3_p),\n        .Y(mmult0_out_pp)\n    );\nstoch_matrix_mult #(\n        .NUM_ROWS(2),\n        .NUM_MID(2),\n        .NUM_COLS(1)\n    ) mmult0_pm (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(net_2_p),\n        .B(net_3_m),\n        .Y(mmult0_out_pm)\n    );\nstoch_matrix_mult #(\n        .NUM_ROWS(2),\n        .NUM_MID(2),\n        .NUM_COLS(1)\n    ) mmult0_mp (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(net_2_m),\n        .B(net_3_p),\n        .Y(mmult0_out_mp)\n    );\nstoch_matrix_mult #(\n        .NUM_ROWS(2),\n        .NUM_MID(2),\n        .NUM_COLS(1)\n    ) mmult0_mm (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(net_2_m),\n        .B(net_3_m),\n        .Y(mmult0_out_mm)\n    );\nstoch_sat_sub_mat #(\n        .NUM_ROWS(2),\n        .NUM_COLS(1)\n    ) mmult0_11 (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(mmult0_out_pp),\n        .B(mmult0_out_pm),\n        .Y(mmult0_out_11)\n    );\nstoch_sat_sub_mat #(\n        .NUM_ROWS(2),\n        .NUM_COLS(1)\n    ) mmult0_12 (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(mmult0_out_pm),\n        .B(mmult0_out_pp),\n        .Y(mmult0_out_12)\n    );\nstoch_sat_sub_mat #(\n        .NUM_ROWS(2),\n        .NUM_COLS(1)\n    ) mmult0_13 (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(mmult0_out_mp),\n        .B(mmult0_out_mm),\n        .Y(mmult0_out_13)\n    );\nstoch_sat_sub_mat #(\n        .NUM_ROWS(2),\n        .NUM_COLS(1)\n    ) mmult0_14 (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(mmult0_out_mm),\n        .B(mmult0_out_mp),\n        .Y(mmult0_out_14)\n    );\nstoch_add_mat #(\n        .NUM_ROWS(2),\n        .NUM_COLS(1)\n    ) mmult0_p (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(mmult0_out_11),\n        .B(mmult0_out_14),\n        .Y(net_4_p)\n    );\nstoch_add_mat #(\n        .NUM_ROWS(2),\n        .NUM_COLS(1)\n    ) mmult0_m (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(mmult0_out_12),\n        .B(mmult0_out_13),\n        .Y(net_4_m)\n    );\n// END mmult0\n\n// Autogenerated by BitSAD\n// BEGIN fdiv0\nstoch_fixed_gain_div_mat #(\n        .GAIN(net_6),\n        .NUM_ROWS(2),\n        .NUM_COLS(1)\n    ) fdiv0_p (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(net_4_p),\n        .Y(net_7_p)\n    );\nstoch_fixed_gain_div_mat #(\n        .GAIN(net_6),\n        .NUM_ROWS(2),\n        .NUM_COLS(1)\n    ) fdiv0_m (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(net_4_m),\n        .Y(net_7_m)\n    );\n// END fdiv0\n\n// Autogenerated by BitSAD\n// BEGIN l2norm0\nstoch_l2_norm #(\n        .VEC_LEN(2)\n    ) l2norm0 (\n        .CLK  (CLK),\n        .nRST (nRST),\n        .up   (net_7_p),\n        .un   (net_7_m),\n        .yp   (net_10_p),\n        .yn   (net_10_m)\n    );\n// END l2norm0\n\n// Autogenerated by BitSAD\n// BEGIN div0\nstoch_div_mat #(\n        .NUM_ROWS(2),\n        .NUM_COLS(1)\n    ) div0_pp (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(net_7_p),\n        .B({2{net_10_p}}),\n        .Y(div0_out_pp)\n    );\nstoch_div_mat #(\n        .NUM_ROWS(2),\n        .NUM_COLS(1)\n    ) div0_mp (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(net_7_m),\n        .B({2{net_10_p}}),\n        .Y(div0_out_mp)\n    );\nstoch_sat_sub_mat #(\n        .NUM_ROWS(2),\n        .NUM_COLS(1)\n    ) div0_p (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(div0_out_pp),\n        .B(div0_out_mp),\n        .Y(net_11_p)\n    );\nstoch_sat_sub_mat #(\n        .NUM_ROWS(2),\n        .NUM_COLS(1)\n    ) div0_m (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(div0_out_mp),\n        .B(div0_out_pp),\n        .Y(net_11_m)\n    );\n// END div0\n\n// Autogenerated by BitSAD\n// BEGIN mmult1\nstoch_matrix_mult #(\n        .NUM_ROWS(2),\n        .NUM_MID(2),\n        .NUM_COLS(1)\n    ) mmult1_pp (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(net_14_p),\n        .B(net_11_p),\n        .Y(mmult1_out_pp)\n    );\nstoch_matrix_mult #(\n        .NUM_ROWS(2),\n        .NUM_MID(2),\n        .NUM_COLS(1)\n    ) mmult1_pm (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(net_14_p),\n        .B(net_11_m),\n        .Y(mmult1_out_pm)\n    );\nstoch_matrix_mult #(\n        .NUM_ROWS(2),\n        .NUM_MID(2),\n        .NUM_COLS(1)\n    ) mmult1_mp (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(net_14_m),\n        .B(net_11_p),\n        .Y(mmult1_out_mp)\n    );\nstoch_matrix_mult #(\n        .NUM_ROWS(2),\n        .NUM_MID(2),\n        .NUM_COLS(1)\n    ) mmult1_mm (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(net_14_m),\n        .B(net_11_m),\n        .Y(mmult1_out_mm)\n    );\nstoch_sat_sub_mat #(\n        .NUM_ROWS(2),\n        .NUM_COLS(1)\n    ) mmult1_11 (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(mmult1_out_pp),\n        .B(mmult1_out_pm),\n        .Y(mmult1_out_11)\n    );\nstoch_sat_sub_mat #(\n        .NUM_ROWS(2),\n        .NUM_COLS(1)\n    ) mmult1_12 (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(mmult1_out_pm),\n        .B(mmult1_out_pp),\n        .Y(mmult1_out_12)\n    );\nstoch_sat_sub_mat #(\n        .NUM_ROWS(2),\n        .NUM_COLS(1)\n    ) mmult1_13 (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(mmult1_out_mp),\n        .B(mmult1_out_mm),\n        .Y(mmult1_out_13)\n    );\nstoch_sat_sub_mat #(\n        .NUM_ROWS(2),\n        .NUM_COLS(1)\n    ) mmult1_14 (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(mmult1_out_mm),\n        .B(mmult1_out_mp),\n        .Y(mmult1_out_14)\n    );\nstoch_add_mat #(\n        .NUM_ROWS(2),\n        .NUM_COLS(1)\n    ) mmult1_p (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(mmult1_out_11),\n        .B(mmult1_out_14),\n        .Y(net_15_p)\n    );\nstoch_add_mat #(\n        .NUM_ROWS(2),\n        .NUM_COLS(1)\n    ) mmult1_m (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(mmult1_out_12),\n        .B(mmult1_out_13),\n        .Y(net_15_m)\n    );\n// END mmult1\n\n// Autogenerated by BitSAD\n// BEGIN fdiv1\nstoch_fixed_gain_div_mat #(\n        .GAIN(net_17),\n        .NUM_ROWS(2),\n        .NUM_COLS(1)\n    ) fdiv1_p (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(net_15_p),\n        .Y(net_18_p)\n    );\nstoch_fixed_gain_div_mat #(\n        .GAIN(net_17),\n        .NUM_ROWS(2),\n        .NUM_COLS(1)\n    ) fdiv1_m (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(net_15_m),\n        .Y(net_18_m)\n    );\n// END fdiv1\n\n// Autogenerated by BitSAD\n// BEGIN l2norm1\nstoch_l2_norm #(\n        .VEC_LEN(2)\n    ) l2norm1 (\n        .CLK  (CLK),\n        .nRST (nRST),\n        .up   (net_18_p),\n        .un   (net_18_m),\n        .yp   (net_21_p),\n        .yn   (net_21_m)\n    );\n// END l2norm1\n\n// Autogenerated by BitSAD\n// BEGIN div1\nstoch_div_mat #(\n        .NUM_ROWS(2),\n        .NUM_COLS(1)\n    ) div1_pp (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(net_18_p),\n        .B({2{net_21_p}}),\n        .Y(div1_out_pp)\n    );\nstoch_div_mat #(\n        .NUM_ROWS(2),\n        .NUM_COLS(1)\n    ) div1_mp (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(net_18_m),\n        .B({2{net_21_p}}),\n        .Y(div1_out_mp)\n    );\nstoch_sat_sub_mat #(\n        .NUM_ROWS(2),\n        .NUM_COLS(1)\n    ) div1_p (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(div1_out_pp),\n        .B(div1_out_mp),\n        .Y(net_22_p)\n    );\nstoch_sat_sub_mat #(\n        .NUM_ROWS(2),\n        .NUM_COLS(1)\n    ) div1_m (\n        .CLK(CLK),\n        .nRST(nRST),\n        .A(div1_out_mp),\n        .B(div1_out_pp),\n        .Y(net_22_m)\n    );\n// END div1\n\n\nendmodule\n&quot;, Module power_iteration with 0 parameters and 0 submodules.)</code></pre>
<p>BitSAD does not know how to interpret <code>size(A, 1)</code> in our function. In hardware, we would not compute the array size on the fly. Instead, it would be a parameter of the circuit. To replicate this behavior in BitSAD, we need to use a struct.</p>
<pre><code cell="iterative-svd" class="language-julia">struct PowerIteration
    scalew::Float64
    scalez::Float64
end
PowerIteration(; nrows, ncols) = PowerIteration(sqrt(nrows), sqrt(ncols))

function (circuit::PowerIteration)(A, v₀)
    w = A * v₀
    wscaled = w .÷ circuit.scalew
    u = wscaled ./ norm(wscaled)

    z = permutedims(A) * u
    zscaled = z .÷ circuit.scalez
    σ = norm(zscaled)
    v = zscaled ./ σ

    return u, v, σ
end
</code></pre>
<p>Here, we created the <code>PowerIteration</code> struct which can be instantiated with the matrix size like <code>PowerIteration(m, n)</code>. We made the struct callable, and the body of the function is nearly the same as <code>power_iteration</code>.  The only difference is that we use <code>circuit.scalew</code> instead of <code>sqrt(size(A, 1))</code> (same for the number of columns). We can generate harware for <code>PowerIteration</code> just like we did for regular functions, but now any accesses to the fields of the <code>PowerIteration</code> struct will be treated like parameters in Verilog.</p>
<pre><code cell="iterative-svd" class="language-julia">circuit = PowerIteration(nrows = size(A, 1), ncols = size(A, 2))
power_iteration_verilog, _ = generatehw(circuit, A, v₀)

# print only the first 20 lines
println(join(split(power_iteration_verilog, &quot;\n&quot;)[1:20], &quot;\n&quot;))
</code></pre>
<pre><code class="plaintext cell-output cell-stream">module PowerIteration(CLK, nRST, net_2_p, net_2_m, net_3_p, net_3_m, net_20_p, net_20_m);

parameter scalez = 4'b0101;
parameter scalew = 4'b0101;

input CLK, nRST;
input  [3:0] net_2_p, net_2_m;
input  [1:0] net_3_p, net_3_m;
output  [1:0] net_20_p, net_20_m;

wire  [1:0] net_4_p, net_4_m;
wire  [1:0] net_6_p, net_6_m;
wire   net_9_p, net_9_m;
wire  [1:0] net_10_p, net_10_m;
wire  [3:0] net_13_p, net_13_m;
wire  [1:0] net_14_p, net_14_m;
wire  [1:0] net_16_p, net_16_m;
wire   net_19_p, net_19_m;
wire  [1:0] mmult0_out_pp;
wire  [1:0] mmult0_out_pm;
</code></pre>
<p>We can see that the generated Verilog contains <code>scalew</code> and <code>scalez</code> as parameters, and BitSAD automatically determined the fixed point binary values for them.</p>
</article>
        <div id="page-navigation">
            <a id="previous-page" title="Previous" href="simulation-and-hardware.html"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M16.2426 6.34317L14.8284 4.92896L7.75739 12L14.8285 19.0711L16.2427 17.6569L10.5858 12L16.2426 6.34317Z" fill="currentColor" /></svg></a>
            <a id="next-page" title="Next" href="..&#x2F;how-tos&#x2F;custom-sbitstream.html"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5858 6.34317L12 4.92896L19.0711 12L12 19.0711L10.5858 17.6569L16.2427 12L10.5858 6.34317Z" fill="currentColor" /></svg></a>
        </div>
    </main>
    <nav id="toc"><p><a href="../../README.html">Introduction</a></p>
<h1 id="tutorials"><a href="../../#tutorials" class="anchor"></a>Tutorials</h1>
<ul>
<li><a href="../../docs/tutorials/getting-started.html">Quickstart</a></li>
<li><a href="../../docs/tutorials/sbitstream.html">Stochastic bitstreams 101</a></li>
<li><a href="../../docs/tutorials/simulation-and-hardware.html">Simulation and hardware</a></li>
<li><a href="../../docs/tutorials/iterative-svd.html">Complex functions of bitstreams</a></li>
</ul>
<h1 id="how-to-"><a href="../../#how-to-" class="anchor"></a>How To …</h1>
<ul>
<li><a href="../../docs/how-tos/custom-sbitstream.html">Create a custom <code>SBitstream</code> operator</a></li>
<li><a href="../../docs/how-tos/nosim.html">Create a simulation nop</a></li>
</ul>
<h1 id="developer-guide"><a href="../../#developer-guide" class="anchor"></a>Developer Guide</h1>
<!-- * [Archicture overview](dev-guide/architecture.md) -->
<!-- * [Understanding simulation](dev-guide/simulation.md) -->
<!-- * [Understanding hardware generation](dev-guide/hardware.md) -->
<hr />
<p><a href="../../docstrings.html">API Reference</a></p>
</nav>
    <footer>
        Built with <a target="_blank" href="https://github.com/MichaelHatherly/Publish.jl">Publish.jl</a> and the <a target="_blank" href="https://julialang.org">Julia Language.</a>
    </footer>
    <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
