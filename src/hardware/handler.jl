using Base: @kwdef
import Base: isequal, hash

const stdcomment = "// Autogenerated by Bitstream DSL compiler"

"""
    Operation

An operation is represented by a list of input types,
a list of output types, and an operator.

# Examples:
```julia
# x represents the addition operation on a pair of
#  stochastic bits (which returns a stochastic bit)
x = Operation([:SBit, :SBit], [:SBit], :+)
```
"""
struct Operation
    inputs::Vector{Symbol}
    outputs::Vector{Symbol}
    operator::Symbol
end
isequal(x::Operation, y::Operation) =
    all(x.inputs .== y.inputs) && all(x.outputs .== y.outputs) && (x.operator == y.operator)
hash(x::Operation) = hash(hash(hash(x.inputs), hash(x.outputs)), hash(x.operator))

"""
    AbstractHandler

Inherit from this type to create a Verilog generation handler.

This object is responsible for managing all instantiations
of its associated Verilog module.
It should also update the netlist as it adds nets.
"""
abstract type AbstractHandler end

_handlermap = Dict{Operation, Type}()

"""
    register(op::Operation, handler::AbstractHandler)

Register a mapping from an operation to a handler.

# Examples:
```julia
# register a stochastic add to an add handler
register(Operation([:SBit, :SBit], [:SBit], :+), SAddHandler)
```
"""
register(op::Operation, handler::Type{T}) where T<:AbstractHandler =
    _handlermap[op] = handler

"""
    handler(op, intypes, outtypes)

Return a new handler for the given operation and types.

This function is used by the hardware generation code to get a
new handler for a node in the dataflow graph.
When no suitable handler is found, an error will be returned.

# Fields:
- `op::Symbol`: the operation (e.g. `:+`)
- `intypes::Vector{Symbol}`: a vector of input types (e.g. `[:SBit, :SBit]`)
- `outtypes::Vector{Symbol}`: a vector of output types (e.g. `[:SBit]`)
"""
handler(op::Operation) = haskey(_handlermap, op) ? _handlermap[op] :
    error("""
        Cannot find handler for $(op.operator) ($(op.inputs)) -> $(op.outputs).
        Perhaps you forgot to register a handler for your custom operation?
        """)

@kwdef mutable struct SAddHandler <: AbstractHandler
    id = 0
end

register(Operation([:SBit, :SBit], [:SBit], :+), SAddHandler)
register(Operation([Symbol("Vector{SBit}"), Symbol("Vector{SBit}")], [Symbol("Vector{SBit}")], :+), SAddHandler)
register(Operation([Symbol("Matrix{SBit}"), Symbol("Matrix{SBit}")], [Symbol("Matrix{SBit}")], :+), SAddHandler)

function (handler::SAddHandler)(netlist::Netlist,
                                inputs::Vector{Variable},
                                outputs::Vector{Variable},
                                sizes::Vector{Tuple{Int, Int}})
    # compute output size
    outsize = sizes[1]

    # add internal nets to netlist
    update!(netlist, Net(name = "add$(handler.id)_pp", size = outsize))
    update!(netlist, Net(name = "add$(handler.id)_mm", size = outsize))

    # add output net to netlist
    update!(netlist, Net(name = string(outputs[1].name), signed = true, size = outsize))

    outstring = """
        $stdcomment
        // BEGIN add$(handler.id)
        stoch_add_mat #(
                .NUM_ROWS($(outsize[1])),
                .NUM_COLS($(outsize[2]))
            ) add$(handler.id)_PP (
                .CLK(CLK),
                .nRST(nRST),
                .A($(inputs[1].name)_p),
                .B($(inputs[2].name)_p),
                .Y(add$(handler.id)_pp)
            );
        stoch_add_mat #(
                .NUM_ROWS($(outsize[1])),
                .NUM_COLS($(outsize[2]))
            ) add$(handler.id)_MM (
                .CLK(CLK),
                .nRST(nRST),
                .A($(inputs[1].name)_m),
                .B($(inputs[2].name)_m),
                .Y(add$(handler.id)_mm)
            );
        stoch_sat_sub_mat #(
                .NUM_ROWS($(outsize[1])),
                .NUM_COLS($(outsize[2]))
            ) add$(handler.id)_P (
                .CLK(CLK),
                .nRST(nRST),
                .A(add$(handler.id)_pp),
                .B(add$(handler.id)_mm),
                .Y($(outputs[1].name)_p)
            );
        stoch_sat_sub_mat #(
                .NUM_ROWS($(outsize[1])),
                .NUM_COLS($(outsize[2]))
            ) add$(handler.id)_M (
                .CLK(CLK),
                .nRST(nRST),
                .A(add$(handler.id)_mm),
                .B(add$(handler.id)_pp),
                .Y($(outputs[1].name)_m)
            );
        // END add$(handler.id)
        """

    handler.id += 1

    return outstring
end