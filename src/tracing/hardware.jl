const stdcomment = "// Autogenerated by BitSAD"

function gethandler end
gethandler(::Bool, args...) = gethandler(args...)

is_hardware_primitive(sig...) = is_trace_primitive(sig...)

function generatehw(io::IO, f, args...;
                    top = _nameof(f),
                    submodules = [],
                    transforms = [constantreduction!])
    # get tape and transform
    # if f itself is a primitive, do a manual tape
    if is_hardware_primitive(Ghost.get_type_parameters(Ghost.call_signature(f, args...))...)
        tape = Ghost.Tape()
        inputs = Ghost.inputs!(tape, f, args...)
        if _isstruct(f)
            tape.result = push!(tape, Ghost.mkcall(inputs...))
        else
            tape.result = push!(tape, Ghost.mkcall(f, inputs[2:end]...))
        end
    else
        tape = trace(f, args...;
                    isprimitive = is_hardware_primitive,
                    submodules = submodules)
    end
    transform!(_unbroadcast, tape)
    transform!(_squash_binary_vararg, tape)
    tape = Ghost.Tape(tape.ops, tape.result, tape.parent, tape.meta, TupleCtx())
    transform!(_record_tuples_and_splats, tape)
    transform!(_reroute_tuple_index, tape)
    transform!(_desplat, tape)
    # transform!(_squash_tuple_index, tape)

    # extract tape into module
    m = Module(fn = f, name = top)
    extracttrace!(m, tape)

    # replace constant SBitstreams with calls to SBitstream constructor on floats
    insertrng!(m)

    # apply transformations
    foreach(t! -> t!(m), transforms)

    # replace constants with Verilog strings
    constantreplacement!(m)

    # generate verilog string
    generateverilog(io, m)

    return io, m
end
function generatehw(f, args...; kwargs...)
    buffer = IOBuffer()
    buffer, m = generatehw(buffer, f, args...; kwargs...)

    return String(take!(buffer)), m
end

_getstructname(::T) where T = lowercase(string(nameof(T)))

_handle_parameter(parameter::Number, submodules) = parameter
_handle_parameter(parameter::AbstractArray{<:Number}, submodules) = parameter
_handle_parameter(parameter::Tuple, submodules) = map(parameter) do p
    _handle_parameter(p, submodules)
end
function _handle_parameter(::T, submodules) where T
    (T âˆˆ submodules) || @warn "Parameter of type $T will be ignored (cannot encode in Verilog)"

    return nothing
end

function _handle_getproperty!(m::Module, call, param_map, const_map)
    if m.fn == _gettapeval(call.args[1])
        val = _handle_parameter(_gettapeval(call), m.submodules)
        prop = string(_gettapeval(call.args[2]))
        encodable = (val isa Union{AbstractArray, Tuple}) ? !all(isnothing, val) : !isnothing(val)
        if encodable
            m.parameters[prop] = val
            param_map[_getid(call)] = prop
        end
    else
        const_map[_getid(call)] = string(_gettapeval(call))
    end

    return m
end

function _get_materialize_origin(x)
    origin = _gettapeop(x)

    return (origin.fn == Base.materialize) ? _get_materialize_origin(origin.args[1]) : x
end

function extracttrace!(m::Module, tape::Ghost.Tape)
    # we use ids instead of Ghost.Variables as keys b/c
    # there are hashing issues with Ghost.Variable
    # see https://github.com/dfdx/Ghost.jl/issues/20
    param_map = Dict{Int, String}()
    const_map = Dict{Int, String}()
    materialize_map = Dict{Int, Tuple{Ghost.Variable, Any}}()
    # skip first call which is the function being compiled
    for call in tape
        if call isa Ghost.Call
            # ignore materialize calls
            if call.fn == Base.materialize
                origin = _get_materialize_origin(call.args[1])
                materialize_map[_getid(call)] = (origin, _gettapeval(call))
                continue
            end

            # handle calls to getproperty
            if call.fn == Base.getproperty
                _handle_getproperty!(m, call, param_map, const_map)
                continue
            end

            is_hardware_primitive(Ghost.get_type_parameters(Ghost.call_signature(tape, call))...) ||
                continue

            # create Operator for Ghost.Call (handling broadcast)
            # structs are renamed as Foo -> foo_$id
            # plain functions are name ""
            name = _isstruct(call.fn) ? _getstructname(call.fn) * "_$(_getid(call.fn))" : ""
            isbroadcast = _isbcast(call.fn)
            fn = isbroadcast ? _gettapeval(call.args[1]) : call.fn
            op = (name = Symbol(name), type = typeof(fn), broadcasted = isbroadcast)

            # map inputs and outputs of Ghost.Call to Nets
            # set args that are Ghost.Input to :input class
            inputs = map(call.args[(1 + isbroadcast):end]) do arg
                arg, val = get(materialize_map, _getid(arg), (arg, _gettapeval(arg)))
                name = haskey(param_map, _getid(arg)) ? param_map[_getid(arg)] :
                       haskey(const_map, _getid(arg)) ? const_map[_getid(arg)] :
                       _isvariable(arg) ? "net_$(_getid(arg))" : string(val)
                net = Net(val; name = name)

                if _isvariable(arg)
                    if _isinput(arg)
                        net = setclass(net, :input)
                    elseif haskey(param_map, _getid(arg))
                        net = setclass(net, :parameter)
                    elseif haskey(const_map, _getid(arg))
                        net = setclass(net, :constant)
                    end
                else # treat all non-variables as constants
                    net = setclass(net, :constant)
                end

                return net
            end
            outval = isbroadcast ? Base.materialize(_gettapeval(call)) : _gettapeval(call)
            output = Net(outval; name = "net_$(_getid(call))")

            if tape.result == Ghost.Variable(call)
                output = setclass(output, :output)
            end

            addnode!(m, inputs, [output], op)
        end
    end

    return m
end
